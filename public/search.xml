<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring整合mybatis实现跨库(实现主从查询)]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2018%2F03%2F01%2Fmybatis-cross-database%2F</url>
    <content type="text"><![CDATA[1、简单的实现跨库查询(可以实现主从查询,跨库查询)方法1 配置多个数据源（datasource） 配置多个SqlSessionFactoryBean工场 MapperScannerConfigurer根据不同的mapper目录配置不同的SqlSessionFactory和basePage 注意，同一时间内，只能保证一个数据源的事务(一个方法内包含对两个数据库的操作，你只能保证对一个库有效) 实现如下:数据库表123456789101112131415CREATE TABLE `tb_user` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(50) DEFAULT NULL, `age` tinyint(3) unsigned DEFAULT NULL, `gender` char(2) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;CREATE TABLE `tb_news` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `title` varchar(50) DEFAULT NULL, `author` varchar(50) DEFAULT NULL, `content` varchar(200) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; 数据库链接配置1234567891011#tb_userjdbc.username=rootjdbc.password=rootjdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/test?useSSL=true#tb_newsnews.jdbc.username=rootnews.jdbc.password=rootnews.jdbc.driver=com.mysql.jdbc.Drivernews.jdbc.url=jdbc:mysql://localhost:3306/caogao?useSSL=true mybatis+spring文件配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--user库数据源--&gt; &lt;bean id="userDatasource" class="com.zaxxer.hikari.HikariDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;/bean&gt; &lt;!--new库数据源--&gt; &lt;bean id="newDatasource" class="com.zaxxer.hikari.HikariDataSource"&gt; &lt;property name="driverClassName" value="$&#123;news.jdbc.driver&#125;"/&gt; &lt;property name="username" value="$&#123;news.jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;news.jdbc.password&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;news.jdbc.url&#125;"/&gt; &lt;/bean&gt; &lt;!--userSqlSessionFactory工场--&gt; &lt;bean id="userSqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="userDatasource"/&gt; &lt;property name="mapperLocations" value="classpath:cqut/wys/dao/mapper/user/*.xml"/&gt; &lt;/bean&gt; &lt;!--newSqlSessionFactory工场--&gt; &lt;bean id="newSqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="newDatasource"/&gt; &lt;property name="mapperLocations" value="classpath:cqut/wys/dao/mapper/news/*.xml"/&gt; &lt;/bean&gt; &lt;!--userMapperScannerConfigurer mapper扫描--&gt; &lt;bean id="userMapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cqut.wys.dao.mapper.user"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="userSqlSessionFactory"/&gt; &lt;/bean&gt; &lt;!--newMapperScannerConfigurer mapper扫描--&gt; &lt;bean id="newMapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cqut.wys.dao.mapper.news"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="newSqlSessionFactory"/&gt; &lt;/bean&gt; &lt;!-- userDatasource定义事务管理器 --&gt; &lt;bean id="userTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="userDatasource"/&gt; &lt;/bean&gt; &lt;!-- userDatasource事务支持注解 --&gt; &lt;tx:annotation-driven transaction-manager="userTransactionManager"/&gt; &lt;!-- newDatasource定义事务管理器 --&gt; &lt;bean id="newTransactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="newDatasource"/&gt; &lt;/bean&gt; &lt;!-- newDatasource事务支持注解 --&gt; &lt;tx:annotation-driven transaction-manager="newTransactionManager"/&gt;&lt;/beans&gt; 此跨库的实现方法是: 在mapper包的根目录下，不同数据库新建不同的mapper查询包 MapperScannerConfigurer根据不同的mapper查询包配置不同的basepage,sqlSessionFactoryBeanName MapperScannerConfigurer配置中cqut.wys.dao.mapper.news mapper查询包就使用newSqlSessionFactory和newDatasource的值 此跨库查询方法的优缺点 实现简单 配置繁索，多个数据库就得新建、配置多个sqlSessionFactory和MapperScannerConfigurer。 实现源码:方式1实现跨库查询(可以实现主从查询,跨库查询)方法2 配置多个数据源（datasource） 使用spring的AbstractRoutingDataSource实现多数据源切换 使用spring的aop，根据不同mapper包配置不同的数据源 注意，同一时间内，只能保证一个数据源的事务(一个方法内包含对两个数据库的操作，你只能保证对一个库有效) 实现如下:数据库链接配置1234567891011#tb_userjdbc.username=rootjdbc.password=rootjdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/test?useSSL=true#tb_newsnews.jdbc.username=rootnews.jdbc.password=rootnews.jdbc.driver=com.mysql.jdbc.Drivernews.jdbc.url=jdbc:mysql://localhost:3306/caogao?useSSL=true mybatis+spring文件配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version="1.0" encoding="GBK"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--user库数据源--&gt; &lt;bean id="userDatasource" class="com.zaxxer.hikari.HikariDataSource"&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;jdbc.url&#125;"/&gt; &lt;/bean&gt; &lt;!--new库数据源--&gt; &lt;bean id="newDatasource" class="com.zaxxer.hikari.HikariDataSource"&gt; &lt;property name="driverClassName" value="$&#123;news.jdbc.driver&#125;"/&gt; &lt;property name="username" value="$&#123;news.jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;news.jdbc.password&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;news.jdbc.url&#125;"/&gt; &lt;/bean&gt; &lt;!--动态数据源datasource--&gt; &lt;bean id="datasource" class="cqut.wys.utils.DynamicDataSource"&gt; &lt;!--设置默认数据库源--&gt; &lt;property name="defaultTargetDataSource" ref="userDatasource"/&gt; &lt;property name="targetDataSources"&gt; &lt;map key-type="java.lang.String"&gt; &lt;entry key="userDatasource" value-ref="userDatasource"/&gt; &lt;entry key="newDatasource" value-ref="newDatasource"/&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--数据源切面,选择不同数据源--&gt; &lt;bean id="datasourceAspect" class="cqut.wys.utils.DataSourceAspect"/&gt; &lt;aop:config&gt; &lt;aop:aspect ref="datasourceAspect"&gt; &lt;!--数据源选择,news包选择news库--&gt; &lt;!--同时可以根据mapper前缀不同实现主从分离(选择不同的主从)--&gt; &lt;aop:pointcut id="datasourceSelect" expression="execution(* cqut.wys.dao.mapper.news.*.*(..))"/&gt; &lt;aop:before method="before" pointcut-ref="datasourceSelect"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; &lt;!--sqlSessionFactory工场--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="datasource"/&gt; &lt;property name="mapperLocations" value="classpath:cqut/wys/dao/mapper/**/*.xml"/&gt; &lt;/bean&gt; &lt;!--mapperScannerConfigurer mapper扫描--&gt; &lt;bean id="mapperScannerConfigurer" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cqut.wys.dao.mapper"/&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;/bean&gt; &lt;!--定义事务管理器--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="datasource"/&gt; &lt;/bean&gt; &lt;!-- 事务支持注解 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; 动态数据源选择实现123456789101112131415161718192021222324252627282930313233343536public class DataSourceAspect&#123; private final static String NEWS = "newDatasource"; private final static String USER = "userDatasource"; public void before()&#123; if (DataSourceContextHolder.getDbType() == null) &#123; DataSourceContextHolder.setDbType(NEWS); &#125; &#125;&#125;public class DataSourceContextHolder &#123; private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;(); public static void setDbType(String dbType) &#123; contextHolder.set(dbType); &#125; public static String getDbType() &#123; return contextHolder.get(); &#125; public static void clearDbType() &#123; contextHolder.remove(); &#125;&#125;public class DynamicDataSource extends AbstractRoutingDataSource&#123; @Override protected Object determineCurrentLookupKey() &#123; return DataSourceContextHolder.getDbType(); &#125;&#125; 此跨库查询方法的优缺点 此实现相对方法1来说较复杂 配置简单，使用比方法1灵活 实现源码:方式2springboot整合mybatis实现跨库 springboot整合mybatis实现跨库,实现原理和上面一致。在此不再赘述。 源码地址springboot实现方式1 源码地址springboot实现方式2 参考文档http://blog.csdn.net/millery22/article/details/49465425 http://blog.csdn.net/neosmith/article/details/61202084 https://www.jianshu.com/p/a042ff2ee2ae http://blog.csdn.net/ggjlvzjy/article/details/51544016]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[threadFactory的创建]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F11%2F05%2FthreadFactory-create%2F</url>
    <content type="text"><![CDATA[java创建线程有两种方式 使用Executors去创建 使用ThreadPoolExecutor的方式去创建 阿里巴巴Java开发文档(六)并发处理中线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 Executors返回的线程池对象的弊端如下 FixedThreadPool和SingleThreadPool:允许的请求队列长为Integer.MAX_VALUE，可能会堆积大量的请求，从而导致OOM CachedThreadPool和ScheduledThreadPool:允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致OOM 那我们该如何用ThreadPoolExecutor创建线程池呢？在此我完全参考了dubbo中创建线程池的方法，代码如下。ThreadPool.java代码123456789/** * ThreadPool * * Created by wuyoushan on 2017/10/31. */public interface ThreadPool &#123; Executor getExecutor();&#125; NamedThreadFactory.java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * InternalThreadFactory * * Created by wuyoushan on 2017/11/1. */public class NamedThreadFactory implements ThreadFactory &#123; private static final AtomicInteger POOL_SEQ = new AtomicInteger(1); private final AtomicInteger mThreadNum = new AtomicInteger(1); private final String mPrefix; private final boolean mDaemo; private final ThreadGroup mGroup; public NamedThreadFactory() &#123; this("pool-" + POOL_SEQ.getAndIncrement(), false); &#125; public NamedThreadFactory(String prefix) &#123; this(prefix, false); &#125; public NamedThreadFactory(String prefix, boolean daemo) &#123; mPrefix = prefix + "-thread-"; mDaemo = daemo; SecurityManager s = System.getSecurityManager(); mGroup = (s == null) ? Thread.currentThread().getThreadGroup() : s.getThreadGroup(); &#125; @Override public Thread newThread(Runnable runnable) &#123; String name = mPrefix + mThreadNum.getAndIncrement(); Thread ret = new Thread(mGroup, runnable, name, 0); ret.setDaemon(mDaemo); return ret; &#125; public ThreadGroup getThreadGroup() &#123; return mGroup; &#125;&#125; CachedThreadPool.java代码123456789101112131415161718192021/** * 此线程池可伸缩，线程空闲一分钟后回收，新请求重新创建线程，来源于：&lt;code&gt;Executors.newCachedThreadPool()&lt;/code&gt; * * Created by wuyoushan on 2017/10/31. */public class CachedThreadPool implements ThreadPool &#123; @Override public Executor getExecutor() &#123; String name = "Dubbo"; int cores = 0; int threads = Integer.MAX_VALUE; int queues = 0; int alive = 60 * 1000; return new ThreadPoolExecutor(cores, threads, alive, TimeUnit.MILLISECONDS, queues == 0 ? new SynchronousQueue&lt;Runnable&gt;() : (queues &lt; 0 ? new LinkedBlockingQueue&lt;Runnable&gt;() : new LinkedBlockingQueue&lt;Runnable&gt;(queues)), new NamedThreadFactory(name, true), new ThreadPoolExecutor.AbortPolicy()); &#125;&#125; FixedThreadPool.java代码12345678910111213141516171819/** * 此线程池启动时即创建固定大小的线程数，不做任何伸缩，来源于：&lt;code&gt;Executors.newFixedThreadPool()&lt;/code&gt; * * Created by wuyoushan on 2017/10/31. */public class FixedThreadPool implements ThreadPool&#123; @Override public Executor getExecutor() &#123; String name = "Dubbo"; int threads = 200; int queues = 0; return new ThreadPoolExecutor(threads,threads,0, TimeUnit.MILLISECONDS, queues == 0 ? new SynchronousQueue&lt;Runnable&gt;() : (queues &lt; 0 ? new LinkedBlockingQueue&lt;Runnable&gt;() : new LinkedBlockingQueue&lt;Runnable&gt;(queues)), new NamedThreadFactory(name, true), new ThreadPoolExecutor.AbortPolicy()); &#125;&#125; LimitedThreadPool.java代码1234567891011121314151617181920/** * 此线程池一直增长，直到上限，增长后不收缩。 * * Created by wuyoushan on 2017/10/31. */public class LimitedThreadPool implements ThreadPool&#123; @Override public Executor getExecutor() &#123; String name = "Dubbo"; int cores = 0; int threads = 200; int queues = 0; return new ThreadPoolExecutor(cores,threads,Long.MAX_VALUE, TimeUnit.MILLISECONDS, queues == 0 ? new SynchronousQueue&lt;Runnable&gt;() : (queues &lt; 0 ? new LinkedBlockingQueue&lt;Runnable&gt;() : new LinkedBlockingQueue&lt;Runnable&gt;(queues)), new NamedThreadFactory(name, true), new ThreadPoolExecutor.AbortPolicy()); &#125;&#125; 注意:上面的线程池的创建和JDK中Executors基于Executors和ThreadPoolExecutor是有所差异的。 dubbo中线程池创建的线程为守护进程，而使用Executors和ThreadPoolExecutor默认线程工厂创建的线程池为非守护线程。 dubbo中根据参数使用的阻塞队列，以及定义队列的长度都是不一样的。 上面代码完全参考自dubbo项目源码git地址 https://github.com/alibaba/dubbo]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程 Callable和Future的使用]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F10%2F24%2Fthread-future-callable%2F</url>
    <content type="text"><![CDATA[Callable和Future的定义CallableCallable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常。 FutureFuture 表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并获取计算的结果。计算完成后只能使用 get 方法来获取结果，如有必要，计算完成前可以阻塞此方法。取消则由 cancel 方法来执行。还提供了其他方法，以确定任务是正常完成还是被取消了。一旦计算完成，就不能再取消计算。如果为了可取消性而使用 Future 但又不提供可用的结果，则可以声明 Future&lt;?&gt; 形式类型、并返回 null 作为底层任务的结果。 FutureTask此类提供了对 Future 的基本实现。仅在计算完成时才能获取结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。 可使用 FutureTask 包装 Callable 或 Runnable 对象。因为 FutureTask 实现了 Runnable，所以可将 FutureTask 提交给 Executor 执行。 使用Callable和Future,FutureTask实现的一些例子例子1: Future和Callable的简单使用1234567891011121314151617181920212223242526272829303132333435363738/** * Created by wuyoushan on 2017/10/24. */public class CallableImpl implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; Thread.sleep(1000); int i=ThreadLocalRandom.current().nextInt(100); System.out.println("CallableImpl返回值为:"+i);// throw new IllegalArgumentException(); return i; &#125;&#125;/** * Created by wuyoushan on 2017/10/24. */public class Test &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ExecutorService threadPool = new ThreadPoolExecutor(4, 16, 20L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(1024)); Callable callable = new CallableImpl(); Future&lt;Integer&gt; future = threadPool.submit(callable); System.out.println("haha"); System.out.println("futurn="+future.get()); Future&lt;Integer&gt; future1 = threadPool.submit(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; return 123; &#125; &#125;); System.out.println("haha"); System.out.println("future1="+future1.get()); &#125;&#125; 运行结果为:12345hahaCallableImpl返回值为:82futurn=82hahafuture1=12312 从上面获取到的异步执行的结果，future.get()方法将会阻塞顺序执行的过程(同理抛出异常的时候，同样会阻塞顺序进程),但当没有使用future.get()方法时则不会阻塞。 例子2: FutureTask的简单使用1234567891011121314151617181920212223242526272829303132333435363738/** * Created by wuyoushan on 2017/10/24. */public class Test &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; long startTime=System.currentTimeMillis(); ExecutorService threadPool = new ThreadPoolExecutor(4, 16, 20L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(1024)); FutureTask&lt;Integer&gt; futureTask=new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; Thread.sleep(1000); return 123; &#125; &#125;); FutureTask&lt;Integer&gt; futureTask1=new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; Thread.sleep(2000); return 321; &#125; &#125;); threadPool.execute(futureTask); new Thread(futureTask1).start(); long endTime=System.currentTimeMillis(); System.out.println("花费时间为="+(endTime-startTime)); System.out.println("futureTask="+futureTask.get()); System.out.println("futureTask1="+futureTask1.get()); System.out.println("haha"); long endTime1=System.currentTimeMillis(); System.out.println("花费时间为="+(endTime1-startTime)); &#125;&#125; 运行结果为:12345花费时间为=5futureTask=123futureTask1=321haha花费时间为=2005 FutureTask创建的异步线程，线程池执行的方式不一样的，同时FutureTask还可以使用Thread()执行获取异步结果。其他的使用和Future基本相同 例子3: 异步批量获取结果集12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class ForFutureExec &#123; private final static ExecutorService pool = new ThreadPoolExecutor(4, 16, 20L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(1024)); public static void main(String[] args) throws ExecutionException, InterruptedException &#123; Long start=System.currentTimeMillis(); List&lt;Future&gt; list=listFuture(1); for (Future future:list)&#123; System.out.println(future.get()); &#125; Long end=System.currentTimeMillis(); System.out.println("消耗时间="+(end-start)); &#125; private static List&lt;Future&gt; listFuture(Integer id)&#123; Future&lt;Integer&gt; future1=pool.submit(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; return countNum1(id); &#125; &#125;); Future&lt;Integer&gt; future2=pool.submit(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; return countNum2(id); &#125; &#125;); Future&lt;Integer&gt; future3=pool.submit(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; return countNum3(id); &#125; &#125;); List&lt;Future&gt; list=new ArrayList&lt;&gt;(); list.add(future1); list.add(future3); list.add(future2); return list; &#125; private static int countNum1(Integer id)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Thread.currentThread().getId(); int num=new Random().nextInt(10); String str=String.format("返回输出的结果=%d,当前线程=%d,休眠时间=%d",num,Thread.currentThread().getId(),1000); System.out.println(str); return num; &#125; private static int countNum2(Integer id)&#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Thread.currentThread().getId(); int num=new Random().nextInt(50); String str=String.format("返回输出的结果=%d,当前线程=%d,休眠时间=%d",num,Thread.currentThread().getId(),2000); System.out.println(str); return num; &#125; private static int countNum3(Integer id)&#123; try &#123; Thread.sleep(6000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Thread.currentThread().getId(); int num=new Random().nextInt(100); String str=String.format("返回输出的结果=%d,当前线程=%d,休眠时间=%d",num,Thread.currentThread().getId(),6000); System.out.println(str); return num; &#125;&#125; 运行结果:由于list中添加顺序的不同导致输出的也不一样1234//由于list添加future的顺序不一样会导致输出的结果有所差异list.add(future1); //休眠1000list.add(future3); //休眠6000list.add(future2); //休眠2000 输出结果1234567返回输出的结果=7,当前线程=9,休眠时间=10007返回输出的结果=34,当前线程=10,休眠时间=2000返回输出的结果=81,当前线程=11,休眠时间=60008134消耗时间=6005 当list的顺序改变时输出的结果也会改变123list.add(future1); //休眠1000list.add(future2); //休眠2000list.add(future3); //休眠6000 输出结果为:1234567返回输出的结果=9,当前线程=9,休眠时间=10009返回输出的结果=3,当前线程=10,休眠时间=20003返回输出的结果=14,当前线程=11,休眠时间=600014消耗时间=6004 例子4: 异步批量获取结果集4123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Created by wuyoushan on 2017/10/19. */public class Test &#123; private final static ExecutorService pool = new ThreadPoolExecutor(4, 16, 20L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(1024)); public static void main(String[] args) throws ExecutionException, InterruptedException &#123; Long start=System.currentTimeMillis(); List&lt;Future&gt; list=new ArrayList&lt;&gt;(8); //异步执行 for (int i=1;i&lt;4;i++)&#123; list.add(asynExec(i*1000)); &#125; //异步执行 for (int j=4;j&gt;1;j--)&#123; list.add(asynExec(j*1000)); &#125; for (Future future:list)&#123; System.out.println(future.get()); &#125; Long end=System.currentTimeMillis(); System.out.println("异步执行消耗时间="+(end-start)); Long start1=System.currentTimeMillis(); List&lt;Integer&gt; list1=new ArrayList&lt;&gt;(4); //同步执行 for (int i=1;i&lt;4;i++)&#123; list1.add(synchronizedExec(i*1000)); &#125; //同步执行 for (int j=4;j&gt;1;j--)&#123; list1.add(synchronizedExec(j*1000)); &#125; for (int result:list1)&#123; System.out.println(result); &#125; Long end1=System.currentTimeMillis(); System.out.println("同步执行消耗时间="+(end1-start1)); &#125; private static Future&lt;Integer&gt; asynExec(int time)&#123; Future&lt;Integer&gt; future=pool.submit(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; return countNum(time); &#125; &#125;); return future; &#125; private static int synchronizedExec(int time)&#123; return countNum(time); &#125; private static int countNum(int time)&#123; try &#123; Thread.sleep(time); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Thread.currentThread().getId(); int num=new Random().nextInt(10); String str=String.format("返回输出的结果=%d,当前线程=%d,休眠时间=%d",num,Thread.currentThread().getId(),time); System.out.println(str); return num; &#125;&#125; 运行结果为:1234567891011121314151617181920212223242526返回输出的结果=8,当前线程=9,休眠时间=10008返回输出的结果=2,当前线程=10,休眠时间=20002返回输出的结果=7,当前线程=11,休眠时间=30007返回输出的结果=1,当前线程=12,休眠时间=40001返回输出的结果=2,当前线程=10,休眠时间=2000返回输出的结果=1,当前线程=9,休眠时间=300012异步执行消耗时间=4033返回输出的结果=4,当前线程=1,休眠时间=1000返回输出的结果=8,当前线程=1,休眠时间=2000返回输出的结果=0,当前线程=1,休眠时间=3000返回输出的结果=3,当前线程=1,休眠时间=4000返回输出的结果=9,当前线程=1,休眠时间=3000返回输出的结果=4,当前线程=1,休眠时间=2000480394同步执行消耗时间=15001]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot构建镜像]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F08%2F09%2Fspringboot-builder-docker%2F</url>
    <content type="text"><![CDATA[基于现成的java镜像，构建发布一个springboot应用的镜像一个简单的springboot地址 系统环境 java 8 Centos7.3 docker 1.12.6 由于springboot应用中内置了应用服务器(默认为tomcat)，根据个人喜好可以修改为jetty或者undertow等应用服务器。springboot程序的运行只依赖于jdk 基于现成的java进行构建springboot镜像 首先从国内的docker镜像中pull拉取docker镜像(默认会从https://hub.docker.com 中拉取镜像)。由于国内的网络状态从官网镜像仓库拉会很不稳定。推荐使用国内进行。在这里我使用的是daocloud国内镜像 查找到的镜像 单击进去查看镜像信息 1docker pull daocloud.io/library/java:openjdk-8u40 也可以将链接改成1docker pull daocloud.io/library/java:latest 表示拉取最新的镜像 拉取完,运行docker images命令查看，镜像已经拉到本地12345[root@localhost log]# docker images;REPOSITORY TAG IMAGE ID CREATED SIZEhub.c.163.com/library/tomcat latest a2fbbcebd67e 4 weeks ago 333.9 MBhub.c.163.com/library/jetty latest 2d50930b2488 12 weeks ago 319.9 MBdaocloud.io/library/java openjdk-8u40 4aefdb29fd43 2 years ago 815.5 MB 创建Dockerfile文件,文件内容如下123456FROM daocloud.io/library/java:latestMAINTAINER yourname XXX@qq.comVOLUME /tmpADD ./springboot-demo-1.0-SNAPSHOT.jar app.jarENV JAVA_OPTS=&quot;&quot;ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar&quot; ] 运行docker build构建镜像(注意最后那个点表示的是当前路径)1docker build -t springboot-web:latest . 运行过程:12345678910111213141516171819202122232425[root@localhost docker]# docker build -t springboot-web:latest .Sending build context to Docker daemon 23.89 MBStep 1 : FROM daocloud.io/library/java ---&gt; d23bdf5b1b1bStep 2 : MAINTAINER yourname XXX@qq.com ---&gt; Running in e964c60f0905 ---&gt; 7c63ec5f8f5fRemoving intermediate container e964c60f0905Step 3 : VOLUME /tmp ---&gt; Running in abe539105b82 ---&gt; 738eeef06071Removing intermediate container abe539105b82Step 4 : ADD ./springboot-demo-1.0-SNAPSHOT.jar app.jar ---&gt; dccf66b86b9fRemoving intermediate container 974b60d0e248Step 5 : ENV JAVA_OPTS &quot;&quot; ---&gt; Running in 7eeea5fda6a7 ---&gt; 591db4ec14b6Removing intermediate container 7eeea5fda6a7Step 6 : ENTRYPOINT sh -c java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar ---&gt; Running in 9456005ad15e ---&gt; eea988cca381Removing intermediate container 9456005ad15eSuccessfully built eea988cca381[root@localhost docker]# 构建成功查看构建成功的镜像123456[root@localhost docker]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEspringboot-web latest dbaafca494ed 11 days ago 667 MBhub.c.163.com/library/tomcat latest a2fbbcebd67e 6 weeks ago 333.9 MBhub.c.163.com/library/jetty latest 2d50930b2488 3 months ago 319.9 MBdaocloud.io/library/java latest d23bdf5b1b1b 6 months ago 643.1 MB 发现有一个springboot-web镜像名，表示我们构建的镜像已经在本地仓库中。 运行构造的springboot-web镜像1docker run -it -d -p 8080:8080 springboot-web 访问地址: http://localhost:8080/user/list 运行结果为:]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程总结]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F08%2F08%2Fthread-summary%2F</url>
    <content type="text"><![CDATA[线程创建的两种方式: 继承Thread类: 123456789class MyThread extends Thread&#123; @Override public void run() &#123; //// TODO &#125;&#125;MyThread mt=new MyThread();mt.start(); 实现Runnable接口:123456789class MyThread implements Runnable &#123; @Override public void run() &#123; //// TODO &#125;&#125;MyThread mt=new MyThread();mt.start(); 线程创建的两种方式比较 Runnable方式可以避免Thread方式由于java单继承特性带来的缺陷 Runnable的代码可以被多个线程(Thread实例)共享,适合于多个线程处理同一资源的情况 Thread模拟买票1. 继承Thread类1234567891011121314151617181920212223242526272829303132333435//定义一个线程类class MyThread extends Thread&#123; private int ticketsCount = 5; //一共有5张火车票 private String name; //窗口，就是线程的名字 public MyThread(String name)&#123; this.name = name; &#125; //创建启动线程的方法 @Override public void run() &#123; while(ticketsCount &gt; 0)&#123; ticketsCount--; //如果还有票，就卖掉一张 System.out.println(name +"卖了1张票，剩余票数为"+ticketsCount); &#125; &#125;&#125;public class TicketsThread &#123; public static void main(String[] args) &#123; //创建3个线程，模拟三个窗口卖票 MyThread mt1 = new MyThread("窗口1"); MyThread mt2 = new MyThread("窗口2"); MyThread mt3 = new MyThread("窗口3"); //启动这三个线程，就是窗口开始卖票 mt1.start(); mt2.start(); mt3.start(); &#125;&#125; 程序的输出结果:12345678910111213141516171819/** 总共只有5张火车票，每个窗口卖了5次，结果卖出15张票，这是不合理的*/窗口1卖了1张票，剩余票数为4窗口1卖了1张票，剩余票数为3窗口1卖了1张票，剩余票数为2窗口1卖了1张票，剩余票数为1窗口1卖了1张票，剩余票数为0窗口2卖了1张票，剩余票数为4窗口2卖了1张票，剩余票数为3窗口2卖了1张票，剩余票数为2窗口2卖了1张票，剩余票数为1窗口2卖了1张票，剩余票数为0窗口3卖了1张票，剩余票数为4窗口3卖了1张票，剩余票数为3窗口3卖了1张票，剩余票数为2窗口3卖了1张票，剩余票数为1窗口3卖了1张票，剩余票数为0 2. 实现Runnable 接口1234567891011121314151617181920212223242526272829303132//创建一个线程类class MyThread1 implements Runnable&#123; private int ticketsCount = 5; //一共有5张火车票 @Override public void run() &#123; //如果ticketsCount不为0，说明还有火车票，可以继续卖 while(ticketsCount &gt; 0 )&#123; ticketsCount--; //Thread.currentThread().getName() 获得当前线程的名字 System.out.println(Thread.currentThread().getName() +"卖了1张票，剩余票数为"+ticketsCount); &#125; &#125;&#125;public class TicketsThread1 &#123; public static void main(String[] args) &#123; MyThread1 mt = new MyThread1(); //创建三个线程,来模拟三个售票窗口 Thread th1 = new Thread(mt,"窗口1"); Thread th2 = new Thread(mt,"窗口2"); Thread th3 = new Thread(mt,"窗口3"); //启动三个线程，就是三个窗口开始卖票 th1.start(); th2.start(); th3.start(); &#125;&#125; 程序的运行结果12345窗口1卖了1张票，剩余票数为4窗口1卖了1张票，剩余票数为3窗口1卖了1张票，剩余票数为2窗口1卖了1张票，剩余票数为1窗口1卖了1张票，剩余票数为0]]></content>
  </entry>
  <entry>
    <title><![CDATA[java线程有两种]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F08%2F08%2Ftwo-kinds-java-threads%2F</url>
    <content type="text"><![CDATA[java线程有两类1. 用户线程:运行在前台,执行具体的任务2. 程序的主线程、连接网络的子线程等都是用户线程守护线程: 运行在后台,为其他前台线程服务 特点: 一旦所有用户线程都结束运行,守护线程会随JVM一起结束工作 应用: 数据库连接池中监测线程 JVM虚拟机启动后的监测线程 最常见的守护线程:垃圾回收线程. 如何设置守护线程 可以通过调用Thread类的setDaemon(true)方法来设置当前的线程为守护线程 注意事项: setDaemon(true)必须在start()方法之前调用,否则会抛出IllegalThreadStateException异常 在守护线程中产生的新线程也是守护线程 不是所有的任务都可以分配给守护线程来执行,比如读写操作或计算逻辑 1234567891011121314151617181920212223242526272829303132333435363738class DaemonThread implements Runnable&#123; @Override public void run() &#123; System.out.println("进入守护进程"+Thread.currentThread().getName()); try &#123; writeToFile(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("退出守护进程"+Thread.currentThread().getName()); &#125; private void writeToFile() throws Exception&#123; File fileName=new File("C:"+File.separator+"daemon.txt"); OutputStream os=new FileOutputStream(fileName,true); int count=0; while (count&lt;999)&#123; os.write(("\r\nword"+count).getBytes()); System.out.println("守护进程"+Thread.currentThread().getName()+"向文件中写入了word"+count++); Thread.sleep(1000); &#125; &#125;&#125;public class DaemonThreadDemo &#123; public static void main(String[] args) &#123; System.out.println("进入主进程"+Thread.currentThread().getName()); DaemonThread daemonThread=new DaemonThread(); Thread thread=new Thread(daemonThread); thread.setDaemon(true); thread.start(); Scanner sc=new Scanner(System.in); sc.next(); System.out.println("退出退出主进程"+Thread.currentThread().getName()); &#125;&#125; 向程序输入:dd123456789进入主进程main进入守护进程Thread-0守护进程Thread-0向文件中写入了word0守护进程Thread-0向文件中写入了word1守护进程Thread-0向文件中写入了word2守护进程Thread-0向文件中写入了word3dd守护进程Thread-0向文件中写入了word4退出退出主进程main 程序的运行结果:]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.1.5方法scheduleAtFixedRete(TimerTask task,Date firstTime,long period)的测试]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Ftimer-schedule-four%2F</url>
    <content type="text"><![CDATA[方法schedule和方法scheduleAtFixedRate都会按顺序执行，所以不要考虑非线程安全的情况。方法schedule和方法scheduleAtFixedRate只在于不延时的情况。 使用schedule方法:如果执行任务的时间没有被延时，那么下一次任务的执行时间参考的是上一次任务的“开始”时的时间来计算。 使用scheduleAtFixedRate方法:如果执行任务的时间没有被延时，那么下一次任务的执行时间参考的是上一次任务的“结束”时的时间来计算。 延时的情况则没有区别，也就是使用schedule或scheduleAtFixedRate方法都是如果执行任务的时间被延时，那么下一次任务的执行时间参考的是上一次任务“结束”时的时间来计算。 1. 测试schedule方法任务不延时 12345678910111213141516171819202122232425262728293031323334353637383940/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; private static Timer timer=new Timer(); private static int runCount=0; static public class MyTask1 extends TimerTask &#123; @Override public void run() &#123; try&#123; System.out.println("1 begin 运行了！时间为:"+new Date()); Thread.sleep(1000); System.out.println("1 end 运行了！时间为:"+new Date()); runCount++; if (runCount==5)&#123; timer.cancel(); &#125; &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; try &#123; MyTask1 task = new MyTask1(); SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString="2017-05-19 08:44:00"; Date dateRef=sdf.parse(dateString); System.out.println("字符串时间:"+dateRef.toString()+"当前时间:"+new Date().toString()); timer.schedule(task,dateRef,3000); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:1234567891011字符串时间:Fri May 19 08:44:00 CST 2017当前时间:Mon May 22 08:12:39 CST 20171 begin 运行了！时间为:Mon May 22 08:12:39 CST 20171 end 运行了！时间为:Mon May 22 08:12:40 CST 20171 begin 运行了！时间为:Mon May 22 08:12:42 CST 20171 end 运行了！时间为:Mon May 22 08:12:43 CST 20171 begin 运行了！时间为:Mon May 22 08:12:45 CST 20171 end 运行了！时间为:Mon May 22 08:12:46 CST 20171 begin 运行了！时间为:Mon May 22 08:12:48 CST 20171 end 运行了！时间为:Mon May 22 08:12:49 CST 20171 begin 运行了！时间为:Mon May 22 08:12:51 CST 20171 end 运行了！时间为:Mon May 22 08:12:52 CST 2017 控制台大印的结果证明，在不延迟的情况下，如果执行任务的时间没有被延时，则下一次执行任务的时间是上一次任务的开始时间加上delay时间 2. 测试schedule方法任务12345678910111213141516171819202122232425262728293031323334353637383940/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; private static Timer timer=new Timer(); private static int runCount=0; static public class MyTask1 extends TimerTask &#123; @Override public void run() &#123; try&#123; System.out.println("1 begin 运行了！时间为:"+new Date()); Thread.sleep(5000); System.out.println("1 end 运行了！时间为:"+new Date()); runCount++; if (runCount==5)&#123; timer.cancel(); &#125; &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; try &#123; MyTask1 task = new MyTask1(); SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString="2017-05-20 08:44:00"; Date dateRef=sdf.parse(dateString); System.out.println("字符串时间:"+dateRef.toString()+"当前时间:"+new Date().toString()); timer.schedule(task,dateRef,2000); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:1234567891011字符串时间:Sat May 20 08:44:00 CST 2017当前时间:Mon May 22 08:23:35 CST 20171 begin 运行了！时间为:Mon May 22 08:23:35 CST 20171 end 运行了！时间为:Mon May 22 08:23:40 CST 20171 begin 运行了！时间为:Mon May 22 08:23:40 CST 20171 end 运行了！时间为:Mon May 22 08:23:45 CST 20171 begin 运行了！时间为:Mon May 22 08:23:45 CST 20171 end 运行了！时间为:Mon May 22 08:23:50 CST 20171 begin 运行了！时间为:Mon May 22 08:23:50 CST 20171 end 运行了！时间为:Mon May 22 08:23:55 CST 20171 begin 运行了！时间为:Mon May 22 08:23:55 CST 20171 end 运行了！时间为:Mon May 22 08:24:00 CST 2017 从控制台打印的结果来看，如果执行任务的时间被延迟，那么下一次任务的执行时间以上一次任务“结束”时的时间为参考计算 3. 测试scheduleAtFixedRate方法任务不延时12345678910111213141516171819202122232425262728293031323334353637383940/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; private static Timer timer=new Timer(); private static int runCount=0; static public class MyTask1 extends TimerTask &#123; @Override public void run() &#123; try&#123; System.out.println("1 begin 运行了！时间为:"+new Date()); Thread.sleep(2000); System.out.println("1 end 运行了！时间为:"+new Date()); runCount++; if (runCount==5)&#123; timer.cancel(); &#125; &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; try &#123; MyTask1 task = new MyTask1(); SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString="2017-05-20 08:44:00"; Date dateRef=sdf.parse(dateString); System.out.println("字符串时间:"+dateRef.toString()+"当前时间:"+new Date().toString()); timer.schedule(task,dateRef,3000); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:1234567891011字符串时间:Sat May 20 08:44:00 CST 2017当前时间:Mon May 22 08:25:46 CST 20171 begin 运行了！时间为:Mon May 22 08:25:46 CST 20171 end 运行了！时间为:Mon May 22 08:25:48 CST 20171 begin 运行了！时间为:Mon May 22 08:25:49 CST 20171 end 运行了！时间为:Mon May 22 08:25:51 CST 20171 begin 运行了！时间为:Mon May 22 08:25:52 CST 20171 end 运行了！时间为:Mon May 22 08:25:54 CST 20171 begin 运行了！时间为:Mon May 22 08:25:55 CST 20171 end 运行了！时间为:Mon May 22 08:25:57 CST 20171 begin 运行了！时间为:Mon May 22 08:25:58 CST 20171 end 运行了！时间为:Mon May 22 08:26:00 CST 2017 控制台打印的结果证明，如果执行任务的时间没有被延迟时，则下一次执行任务的时间是上一次任务的开始时间加上delay时间。 4. 测试scheduleAtFixedRate方法任务延时12345678910111213141516171819202122232425262728293031323334353637383940/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; private static Timer timer=new Timer(); private static int runCount=0; static public class MyTask1 extends TimerTask &#123; @Override public void run() &#123; try&#123; System.out.println("1 begin 运行了！时间为:"+new Date()); Thread.sleep(5000); System.out.println("1 end 运行了！时间为:"+new Date()); runCount++; if (runCount==5)&#123; timer.cancel(); &#125; &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; try &#123; MyTask1 task = new MyTask1(); SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString="2017-05-20 08:44:00"; Date dateRef=sdf.parse(dateString); System.out.println("字符串时间:"+dateRef.toString()+"当前时间:"+new Date().toString()); timer.scheduleAtFixedRate(task,dateRef,2000); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:1234567891011字符串时间:Sat May 20 08:44:00 CST 2017当前时间:Mon May 22 08:46:03 CST 20171 begin 运行了！时间为:Mon May 22 08:46:03 CST 20171 end 运行了！时间为:Mon May 22 08:46:08 CST 20171 begin 运行了！时间为:Mon May 22 08:46:08 CST 20171 end 运行了！时间为:Mon May 22 08:46:13 CST 20171 begin 运行了！时间为:Mon May 22 08:46:13 CST 20171 end 运行了！时间为:Mon May 22 08:46:18 CST 20171 begin 运行了！时间为:Mon May 22 08:46:18 CST 20171 end 运行了！时间为:Mon May 22 08:46:23 CST 20171 begin 运行了！时间为:Mon May 22 08:46:23 CST 20171 end 运行了！时间为:Mon May 22 08:46:28 CST 2017 从控制台打印的结果来看，如果执行任务的时间被延迟时，那么下一次任务的执行时间以上一次任务“结束”时的时间为参考来计算。 5. 验证schedule方法不具有追赶执行性1234567891011121314151617181920212223242526272829/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; private static Timer timer=new Timer(); static public class MyTask1 extends TimerTask &#123; @Override public void run() &#123; System.out.println("1 begin 运行了！时间为:"+new Date()); System.out.println("1 end 运行了！时间为:"+new Date()); &#125; &#125; public static void main(String[] args) &#123; try &#123; MyTask1 task = new MyTask1(); SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString="2017-05-20 08:44:00"; Date dateRef=sdf.parse(dateString); System.out.println("字符串时间:"+dateRef.toString()+"当前时间:"+new Date().toString()); timer.schedule(task,dateRef,5000); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:123456789字符串时间:Sat May 20 08:44:00 CST 2017当前时间:Mon May 22 08:39:29 CST 20171 begin 运行了！时间为:Mon May 22 08:39:29 CST 20171 end 运行了！时间为:Mon May 22 08:39:29 CST 20171 begin 运行了！时间为:Mon May 22 08:39:34 CST 20171 end 运行了！时间为:Mon May 22 08:39:34 CST 20171 begin 运行了！时间为:Mon May 22 08:39:39 CST 20171 end 运行了！时间为:Mon May 22 08:39:39 CST 20171 begin 运行了！时间为:Mon May 22 08:39:44 CST 20171 end 运行了！时间为:Mon May 22 08:39:44 CST 2017 6. 验证scheduleAtFixedRate方法具有追赶执行性1234567891011121314151617181920212223242526272829/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; private static Timer timer=new Timer(); static public class MyTask1 extends TimerTask &#123; @Override public void run() &#123; System.out.println("1 begin 运行了！时间为:"+new Date()); System.out.println("1 end 运行了！时间为:"+new Date()); &#125; &#125; public static void main(String[] args) &#123; try &#123; MyTask1 task = new MyTask1(); SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString="2017-05-20 08:44:00"; Date dateRef=sdf.parse(dateString); System.out.println("字符串时间:"+dateRef.toString()+"当前时间:"+new Date().toString()); timer.scheduleAtFixedRate(task,dateRef,2000); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:12345678910111213end 运行了！时间为:Mon May 22 08:52:24 CST 20171 begin 运行了！时间为:Mon May 22 08:52:24 CST 20171 end 运行了！时间为:Mon May 22 08:52:24 CST 20171 begin 运行了！时间为:Mon May 22 08:52:24 CST 20171 end 运行了！时间为:Mon May 22 08:52:24 CST 20171 begin 运行了！时间为:Mon May 22 08:52:24 CST 20171 end 运行了！时间为:Mon May 22 08:52:24 CST 20171 begin 运行了！时间为:Mon May 22 08:52:24 CST 20171 end 运行了！时间为:Mon May 22 08:52:24 CST 20171 begin 运行了！时间为:Mon May 22 08:52:24 CST 20171 end 运行了！时间为:Mon May 22 08:52:24 CST 20171 begin 运行了！时间为:Mon May 22 08:52:24 CST 20171 end 运行了！时间为:Mon May 22 08:52:24 CST 2017 两个时间段内所对应的Task任务被“补充性”执行了，这就是Task任务追赶执行的特性。 摘选自 java多线程核心编程技术-5.1.5]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>读书笔记</tag>
        <tag>定时器timer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.1.4方法schedule(TimerTask task,long delay,long period)的测试]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Ftimer-schedule-three%2F</url>
    <content type="text"><![CDATA[该方法的作用是以执行schedule(TimerTask task,long delay,long period)方法当前的时间为参考时间，在此时间基础上延迟指定的毫秒数，再以某一间隔时间无限次数地执行某一任务。1234567891011121314151617181920/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; static public class MyTask extends TimerTask &#123; @Override public void run() &#123; System.out.println("运行了！时间为:" +new Date()); &#125; &#125; public static void main(String[] args) &#123; Timer timer = new Timer(); MyTask task = new MyTask(); System.out.println("当前时间:"+new Date().toString()); timer.schedule(task,3000,5000); &#125;&#125; 程序运行后的结果为:123456当前时间:Fri May 19 08:16:04 CST 2017运行了！时间为:Fri May 19 08:16:07 CST 2017运行了！时间为:Fri May 19 08:16:12 CST 2017运行了！时间为:Fri May 19 08:16:17 CST 2017运行了！时间为:Fri May 19 08:16:22 CST 2017运行了！时间为:Fri May 19 08:16:27 CST 2017 凡是使用方法中带有period参数的，都是无限循环执行TimerTask中的任务。 摘选自 java多线程核心编程技术-5.1.4]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>读书笔记</tag>
        <tag>定时器timer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.1.3方法schedule(TimerTask task,long delay)的测试]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Ftimer-schedule-two%2F</url>
    <content type="text"><![CDATA[5.1.3方法schedule(TimerTask task,long delay)的测试该方法的作用是以执行schedule(TimerTask task,long delay)方法当前的时间为参考时间，在此时间基础上延迟指定的毫秒数后执行一次TimerTask任务。1234567891011121314151617181920/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; static public class MyTask extends TimerTask &#123; @Override public void run() &#123; System.out.println("运行了！时间为:" +new Date()); &#125; &#125; public static void main(String[] args) &#123; Timer timer = new Timer(); MyTask task = new MyTask(); System.out.println("当前时间:"+new Date().toString()); timer.schedule(task, 7000); &#125;&#125; 任务task被延迟7秒执行。程序的运行结果为:12当前时间:Fri May 19 08:07:08 CST 2017运行了！时间为:Fri May 19 08:07:15 CST 2017 摘选自 java多线程核心编程技术-5.1.3]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>读书笔记</tag>
        <tag>定时器timer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.1.2方法schedule(TimerTask task,Date firstTime,long period)的测试]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Ftimer-schedule-one%2F</url>
    <content type="text"><![CDATA[该方法的作用是在指定的期之后，按指定的间隔周期性地无限循环地执行某一任务。 1. 计划任务晚于当前任务:在未来执行的效果1234567891011121314151617181920212223242526/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; static public class MyTask extends TimerTask &#123; @Override public void run() &#123; System.out.println("运行了！时间为:"+new Date()); &#125; &#125; public static void main(String[] args) &#123; try&#123; MyTask task=new MyTask(); SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString="2017-5-15 8:09:00"; Timer timer=new Timer(); Date dateRef=sdf.parse(dateString); System.out.println("字符串时间:"+dateRef.toString()+"当前时间:"+new Date().toString()); timer.schedule(task,dateRef,4000); &#125;catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:12345字符串时间:Tue May 16 08:09:00 CST 2017当前时间:Tue May 16 08:22:17 CST 2017运行了！时间为:Tue May 16 08:22:17 CST 2017运行了！时间为:Tue May 16 08:22:21 CST 2017运行了！时间为:Tue May 16 08:22:25 CST 2017运行了！时间为:Tue May 16 08:22:29 CST 2017 从运行的结果来看，每隔4秒运行一次TimerTask任务，并且是无限期地重复执行。 2. 计划任务早于当前时间：提前运行的效果如果计划时间早于当前时间，则立即执行task任务。12345678910111213public static void main(String[] args) &#123; try&#123; MyTask task=new MyTask(); SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString="2017-5-15 8:09:00"; Timer timer=new Timer(); Date dateRef=sdf.parse(dateString); System.out.println("字符串时间:"+dateRef.toString()+"当前时间:"+new Date().toString()); timer.schedule(task,dateRef,4000); &#125;catch (ParseException e) &#123; e.printStackTrace(); &#125;&#125; 程序的运行结果为:1234字符串时间:Mon May 15 08:09:00 CST 2017当前时间:Tue May 16 08:30:33 CST 2017运行了！时间为:Tue May 16 08:30:33 CST 2017运行了！时间为:Tue May 16 08:30:37 CST 2017运行了！时间为:Tue May 16 08:30:41 CST 2017 3. 任务执行时间被延时1234567891011121314151617181920212223242526272829303132/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; static public class MyTaskA extends TimerTask &#123; @Override public void run() &#123; try &#123; System.out.println("A运行了！时间为:" + new Date()); Thread.sleep(5000); System.out.println("A结束了！时间为:" + new Date()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; try &#123; MyTaskA taskA = new MyTaskA(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString = "2017-5-15 8:09:00"; Timer timer = new Timer(); Date dateRef = sdf.parse(dateString); System.out.println("字符串时间:" + dateRef.toString() + "当前时间:" + new Date().toString()); timer.schedule(taskA, dateRef, 4000); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果:12345字符串时间:Mon May 15 08:09:00 CST 2017当前时间:Tue May 16 08:39:18 CST 2017A运行了！时间为:Tue May 16 08:39:18 CST 2017A结束了！时间为:Tue May 16 08:39:23 CST 2017A运行了！时间为:Tue May 16 08:39:23 CST 2017A结束了！时间为:Tue May 16 08:39:28 CST 2017 任务被延时但还是一个一个顺序执行 4. TimerTask类的cancel()方法 TimerTask类中的cancel()方法的作用是将自身从任务队列中清除123456789101112131415161718192021222324252627282930313233343536/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; static public class MyTaskA extends TimerTask &#123; @Override public void run() &#123; System.out.println("A运行了！时间为:" + new Date()); this.cancel(); &#125; &#125; static public class MyTaskB extends TimerTask &#123; @Override public void run() &#123; System.out.println("B运行了！时间为:" + new Date()); &#125; &#125; public static void main(String[] args) &#123; try &#123; MyTaskA taskA = new MyTaskA(); MyTaskB taskB = new MyTaskB(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString = "2017-5-18 8:09:00"; Timer timer = new Timer(); Date dateRef = sdf.parse(dateString); System.out.println("字符串时间:" + dateRef.toString() + "当前时间:" + new Date().toString()); timer.schedule(taskA, dateRef, 4000); timer.schedule(taskB, dateRef, 4000); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果:1234字符串时间:Thu May 18 08:09:00 CST 2017当前时间:Thu May 18 08:47:24 CST 2017A运行了！时间为:Thu May 18 08:47:24 CST 2017B运行了！时间为:Thu May 18 08:47:24 CST 2017B运行了！时间为:Thu May 18 08:47:28 CST 2017 TimerTask类的cancel()方法是将自身从任务队列中被移除，其他任务不受影响。 5. Timer类的cancel()方法和TimerTask类中的cancel()方法清除自身不同，Timer类中的cancel()方法的作用是将任务队列中的全部任务清空。123456789101112131415161718192021222324252627282930313233343536/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; private static Timer timer=new Timer(); static public class MyTaskA extends TimerTask &#123; @Override public void run() &#123; System.out.println("A运行了！时间为:" + new Date()); timer.cancel(); &#125; &#125; static public class MyTaskB extends TimerTask &#123; @Override public void run() &#123; System.out.println("B运行了！时间为:" + new Date()); &#125; &#125; public static void main(String[] args) &#123; try &#123; MyTaskA taskA = new MyTaskA(); MyTaskB taskB = new MyTaskB(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString = "2017-5-18 8:09:00"; Date dateRef = sdf.parse(dateString); System.out.println("字符串时间:" + dateRef.toString() + "当前时间:" + new Date().toString()); timer.schedule(taskA, dateRef, 4000); timer.schedule(taskB, dateRef, 4000); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:12字符串时间:Thu May 18 08:09:00 CST 2017当前时间:Thu May 18 08:56:39 CST 2017A运行了！时间为:Thu May 18 08:56:39 CST 2017 全部任务都被清除，并且进程被销毁，按钮由红色变成灰色。 6. Timer的cancel()方法注意事项Timer类中的cancel()方法有时并一定会停止执行计划任务，而是正常执行。12345678910111213141516171819202122232425262728293031/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; static int i=0; static public class MyTask extends TimerTask &#123; @Override public void run() &#123; System.out.println("正常执行了" +i); &#125; &#125; public static void main(String[] args) &#123; while (true) &#123; try &#123; i++; Timer timer = new Timer(); MyTask task = new MyTask(); SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString = "2017-5-18 8:09:00"; Date dateRef = sdf.parse(dateString); timer.schedule(task, dateRef); timer.cancel(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 程序运行后的部分结果为:123456789正常执行了2正常执行了163正常执行了347正常执行了542正常执行了622正常执行了739正常执行了751正常执行了852正常执行了1233 这是因为Timer类中的cancel()方法有时并没有争抢到queue锁，所以TimerTask类中的任务继续正常执行。 摘选自 java多线程核心编程技术-5.1.2]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>读书笔记</tag>
        <tag>定时器timer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5.1定时器Timer的使用]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Ftimer-use%2F</url>
    <content type="text"><![CDATA[在JDK库中Timer类主要负责计划任务的功能，也就是在指定的时间开始执行某一个任务。 Timer类的主要作用就是设置计划任务，但封装任务的类却是TimerTask类。 2.1.1方法schedule(TimerTask task,Date Time)的测试 该方法的作用是在指定的日期执行一次某一任务。 1. 执行任务的时间晚于当前时间：在未来执行的效果123456789101112131415161718192021222324252627/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; private static Timer timer=new Timer(); static public class MyTask extends TimerTask &#123; @Override public void run() &#123; System.out.println("运行了！时间为："+new Date()); &#125; &#125; public static void main(String[] args) &#123; try&#123; MyTask task=new MyTask(); SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString="2017-5-12 7:45:00"; Date dateRef=sdf.parse(dateString); System.out.println("字符串时间:"+dateRef.toString()+"当前时间:"+new Date().toString()); timer.schedule(task,dateRef); &#125;catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序运行完后的结果为如下，任务虽然执行完了，但进程还未销毁，呈红色状态12字符串时间:Fri May 12 07:45:00 CST 2017当前时间:Fri May 12 07:43:37 CST 2017运行了！时间为：Fri May 12 07:45:00 CST 2017 为什么会出现这样的情况？在创建Timer对象时，JDK源代码如下：12345678910public Timer()&#123; this("Timer")&#125;此构造方法调用的是如下构造方法public Timer(String name) &#123; thread.setName(name); thread.start();&#125; 查看构造方法可以得知，创建一个Timer就是启动一个新的线程，这个新启动的线程并不是守护线程，他一直在运行。 新建Timer改成守护线程1234567891011121314151617181920212223242526272829/** * @author wuyoushan * @date 2017/5/12. */public class Run1TimerIsDaemon &#123; private static Timer timer=new Timer(true); static public class MyTask extends TimerTask&#123; @Override public void run() &#123; System.out.println("运行了！时间为:"+new Date()); &#125; &#125; public static void main(String[] args) &#123; try&#123; MyTask task=new MyTask(); SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString="2017-5-12 8:02:00"; Date dateRef=sdf.parse(dateString); System.out.println("字符串时间:"+dateRef.toString()+"当前时间:"+new Date().toString()); timer.schedule(task,dateRef); &#125;catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:1字符串时间:Fri May 12 08:02:00 CST 2017当前时间:Fri May 12 08:01:16 CST 2017 程序运行后迅速结束当前的进程，并且TimerTask中的任务不再被运行，因为进程已经结束了。 2. 计划时间早于当前时间：提前运行的效果 如果执行任务的时间早于当前时间，则立即执行task任务。1234567891011121314151617181920212223242526272829/** * @author wuyoushan * @date 2017/5/12. */public class Run1TimerIsDaemon &#123; private static Timer timer=new Timer(true); static public class MyTask extends TimerTask&#123; @Override public void run() &#123; System.out.println("运行了！时间为:"+new Date()); &#125; &#125; public static void main(String[] args) &#123; try&#123; MyTask task=new MyTask(); SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString="2017-5-12 8:02:00"; Date dateRef=sdf.parse(dateString); System.out.println("字符串时间:"+dateRef.toString()+"当前时间:"+new Date().toString()); timer.schedule(task,dateRef); &#125;catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果如下所示,立即执行task任务:12字符串时间:Fri May 12 08:02:00 CST 2017当前时间:Mon May 15 08:31:51 CST 2017运行了！时间为：Mon May 15 08:31:51 CST 2017 3. 多个TimerTask任务及延时的测试 Timer中允许有多个TimerTask任务。12345678910111213141516171819202122232425262728293031323334353637383940/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; private static Timer timer=new Timer(); static public class MyTask1 extends TimerTask &#123; @Override public void run() &#123; System.out.println("运行了！时间为："+new Date()); &#125; &#125; static public class MyTask2 extends TimerTask &#123; @Override public void run() &#123; System.out.println("运行了！时间为："+new Date()); &#125; &#125; public static void main(String[] args) &#123; try&#123; MyTask1 task1=new MyTask1(); MyTask2 task2=new MyTask2(); SimpleDateFormat sdf1=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); SimpleDateFormat sdf2=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString1="2017-5-15 8:48:00"; String dateString2="2017-5-15 8:49:00"; Date dateRef1=sdf1.parse(dateString1); Date dateRef2=sdf2.parse(dateString2); System.out.println("字符串1时间:"+dateRef1.toString()+"当前时间:"+new Date().toString()); System.out.println("字符串2时间:"+dateRef2.toString()+"当前时间:"+new Date().toString()); timer.schedule(task1,dateRef1); timer.schedule(task2,dateRef2); &#125;catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为：1234字符串1时间:Mon May 15 08:48:00 CST 2017当前时间:Mon May 15 08:47:42 CST 2017字符串2时间:Mon May 15 08:49:00 CST 2017当前时间:Mon May 15 08:47:42 CST 2017运行了！时间为：Mon May 15 08:48:00 CST 2017运行了！时间为：Mon May 15 08:49:00 CST 2017 TimerTask是以队列的方式一个一个被顺序执行的，所以执行的时间有可能和预期的时间不一致，因为前面的任务有可能消耗的时间较长，则后面的任务运行的时间也会被延迟。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; private static Timer timer=new Timer(); static public class MyTask1 extends TimerTask &#123; @Override public void run() &#123; try &#123; System.out.println("1 begin 运行了！时间为："+new Date()); Thread.sleep(20000); System.out.println("1 end 运行了！时间为:"+new Date()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; static public class MyTask2 extends TimerTask &#123; @Override public void run() &#123; System.out.println("2 begin 运行了！时间为："+new Date()); System.out.println("运行了！时间为:"+new Date()); System.out.println("2 end 运行了！时间为:"+new Date()); &#125; &#125; public static void main(String[] args) &#123; try&#123; MyTask1 task1=new MyTask1(); MyTask2 task2=new MyTask2(); SimpleDateFormat sdf1=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); SimpleDateFormat sdf2=new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString1="2017-5-16 8:09:00"; String dateString2="2017-5-16 8:09:00"; Date dateRef1=sdf1.parse(dateString1); Date dateRef2=sdf2.parse(dateString2); System.out.println("字符串1时间:"+dateRef1.toString()+"当前时间:"+new Date().toString()); System.out.println("字符串2时间:"+dateRef2.toString()+"当前时间:"+new Date().toString()); timer.schedule(task1,dateRef1); timer.schedule(task2,dateRef2); &#125;catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:1234567字符串1时间:Tue May 16 08:09:00 CST 2017当前时间:Tue May 16 08:08:11 CST 2017字符串2时间:Tue May 16 08:09:00 CST 2017当前时间:Tue May 16 08:08:11 CST 20171 begin 运行了！时间为：Tue May 16 08:09:00 CST 20171 end 运行了！时间为:Tue May 16 08:09:20 CST 20172 begin 运行了！时间为：Tue May 16 08:09:20 CST 2017运行了！时间为:Tue May 16 08:09:20 CST 20172 end 运行了！时间为:Tue May 16 08:09:20 CST 2017 由于task1需要用时20秒执行完任务，task1开始的时间是8:09以此时间为基准，向后延迟20秒，task2在8:09:20执行任务。因为Task是被放入队列中的，得一个一个顺序运行。 摘选自 java多线程核心编程技术-5.1]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>读书笔记</tag>
        <tag>定时器timer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.4 类InheritableThreadLocal的使用]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2FinheritableThreadLocal-use%2F</url>
    <content type="text"><![CDATA[使用类InheritableThreadLocal可以在子线程中取得父线程继承下来的值 3.4.1 值继承使用InheritableThreadLocal类可以让子线程从父线程中取得值。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @author wuyoushan * @date 2017/5/24. */public class InheritableThreadLocalExt extends InheritableThreadLocal &#123; @Override protected Object initialValue() &#123; return new Date().getTime(); &#125;&#125;/** * @author wuyoushan * @date 2017/5/23. */public class Tools &#123; public static InheritableThreadLocalExt t1=new InheritableThreadLocalExt();&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; @Override public void run() &#123; try&#123; for (int i = 0; i &lt;10; i++) &#123; System.out.println("在ThreadA线程中取值= "+Tools.t1.get()); Thread.sleep(100); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("在Main线程中取值="+Tools.t1.get()); Thread.sleep(100); &#125; Thread.sleep(5000); ThreadA a=new ThreadA(); a.start(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:123456在Main线程中取值=1495584062991在Main线程中取值=1495584062991在Main线程中取值=1495584062991在ThreadA线程中取值= 1495584062991在ThreadA线程中取值= 1495584062991在ThreadA线程中取值= 1495584062991 3.4.2 值继承再修改如果在值继承的同时还可以对值进行进一步的处理那就更好了。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @author wuyoushan * @date 2017/5/24. */public class InheritableThreadLocalExt extends InheritableThreadLocal &#123; @Override protected Object initialValue() &#123; return new Date().getTime(); &#125; @Override protected Object childValue(Object parentValue) &#123; return parentValue+" 我在子线程加的~"; &#125;&#125;/** * @author wuyoushan * @date 2017/5/23. */public class Tools &#123; public static InheritableThreadLocalExt t1=new InheritableThreadLocalExt();&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; @Override public void run() &#123; try&#123; for (int i = 0; i &lt;10; i++) &#123; System.out.println("在ThreadA线程中取值= "+Tools.t1.get()); Thread.sleep(100); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("在Main线程中取值="+Tools.t1.get()); Thread.sleep(100); &#125; Thread.sleep(5000); ThreadA a=new ThreadA(); a.start(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:123456在Main线程中取值=1495584458175在Main线程中取值=1495584458175在Main线程中取值=1495584458175在ThreadA线程中取值= 1495584458175 我在子线程加的~在ThreadA线程中取值= 1495584458175 我在子线程加的~在ThreadA线程中取值= 1495584458175 我在子线程加的~ 但在使用InheritableThreadLocal类需要注意一点的是，如果子线程在取得值的同时，主线程将InheritableThreadLocal中的值进行更改，那么子线程取到的值还是旧值 摘选自 java多线程核心编程技术-3.4]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>读书笔记</tag>
        <tag>threadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.3类ThreadLocal的使用]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2FthreadLocal-use%2F</url>
    <content type="text"><![CDATA[变量值的共享可以使用public static变量的形式，所有的线程都使用同一个public static变量。如果想实现每一个线程都有自己的共享变量该如何解决呢？JDK中提供的类ThreadLocal正是为了解决这样的问题。 类ThreadLocal主要解决的就是每个线程绑定自己的值，可以将ThreadLocal类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据 3.3.1 方法get()与null12345678910111213141516/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static ThreadLocal t1=new ThreadLocal(); public static void main(String[] args) &#123; if(t1.get()==null)&#123; System.out.println("从未放过值"); t1.set("我的值"); &#125; System.out.println(t1.get()); System.out.println(t1.get()); &#125;&#125; 程序的运行结果:123从未放过值我的值我的值 从程序的运行结果来看，第一调用t1对象的get()方法时返回的值是null，通常调用set()方法赋值后顺利取出值并打印到控制台上。类ThreadLocal解决的是变量在不同线程间的隔离性，也就是不同线程拥有自己的值，不同线程中的值是可以放入ThreadLocal类中进行保存的。 3.3.2 验证线程变量的隔离性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @author wuyoushan * @date 2017/5/23. */public class Tools &#123; public static ThreadLocal t1=new ThreadLocal();&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; @Override public void run() &#123; try&#123; for (int i = 0; i &lt;100; i++) &#123; Tools.t1.set("ThreadA"+(i+1)); System.out.println("ThreadA get Value="+Tools.t1.get()); Thread.sleep(200); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; @Override public void run() &#123; try&#123; for (int i = 0; i &lt;100; i++) &#123; Tools.t1.set("ThreadB"+(i+1)); System.out.println("ThreadB get Value="+Tools.t1.get()); Thread.sleep(200); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) &#123; try &#123; ThreadA a=new ThreadA(); ThreadB b=new ThreadB(); a.start(); b.start(); for (int i = 0; i &lt; 100; i++) &#123; Tools.t1.set("Main"+(i+1)); System.out.println("Main get Value="+Tools.t1.get()); Thread.sleep(200); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:123456789101112Main get Value=Main97ThreadB get Value=ThreadB97ThreadA get Value=ThreadA97Main get Value=Main98ThreadB get Value=ThreadB98ThreadA get Value=ThreadA98Main get Value=Main99ThreadB get Value=ThreadB99ThreadA get Value=ThreadA99Main get Value=Main100ThreadB get Value=ThreadB100ThreadA get Value=ThreadA100 虽然3个线程都向t1对象中set()数据值，但每个线程还是能取出自己的数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * @author wuyoushan * @date 2017/5/23. */public class Tools &#123; public static ThreadLocal&lt;Date&gt; t1=new ThreadLocal();&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; @Override public void run() &#123; try&#123; for (int i = 0; i &lt;100; i++) &#123; if(Tools.t1.get()==null)&#123; Tools.t1.set(new Date()); &#125; System.out.println("A "+Tools.t1.get().getTime()); Thread.sleep(100); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; @Override public void run() &#123; try&#123; for (int i = 0; i &lt;100; i++) &#123; if(Tools.t1.get()==null)&#123; Tools.t1.set(new Date()); &#125; System.out.println("B "+Tools.t1.get().getTime()); Thread.sleep(100); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) &#123; try &#123; ThreadA a=new ThreadA(); a.start(); Thread.sleep(1000); ThreadB b=new ThreadB(); b.start(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:12345678910A 1495499916793A 1495499916793B 1495499917792A 1495499916793A 1495499916793B 1495499917792A 1495499916793B 1495499917792B 1495499917792A 1495499916793 运行结果只有两种时间。 在第一次调用ThreadLocal类的get()方法返回值是null，怎么样实现第一次调用get()不返回null呢？也就是具有默认值的效果。 3.3.3 解决get()返回null问题1234567891011121314151617181920212223242526272829/** * @author wuyoushan * @date 2017/5/24. */public class ThreadLocalExt extends ThreadLocal &#123; @Override protected Object initialValue() &#123; return "我是默认值，第一次get不再为null"; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; private static ThreadLocalExt t1=new ThreadLocalExt(); public static void main(String[] args) &#123; if(t1.get()==null)&#123; System.out.println("从未放过值"); t1.set("我的值"); &#125; System.out.println(t1.get()); System.out.println(t1.get()); &#125;&#125; 程序的运行结果为:12我是默认值，第一次get不再为null我是默认值，第一次get不再为null 此案例仅仅证明main线程有自己的值，那其他线程是否会有自己的初始值呢？ 3.3.4 再次验证线程变量的隔离性1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * @author wuyoushan * @date 2017/5/23. */public class Tools &#123; public static ThreadLocalExt t1=new ThreadLocalExt();&#125;/** * @author wuyoushan * @date 2017/5/24. */public class ThreadLocalExt extends ThreadLocal &#123; @Override protected Object initialValue() &#123; return new Date().getTime(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; @Override public void run() &#123; try&#123; for (int i = 0; i &lt;10; i++) &#123; System.out.println("在ThreadA线程中取值= "+Tools.t1.get()); Thread.sleep(100); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) &#123; try &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println("在Main线程中取值="+Tools.t1.get()); Thread.sleep(100); &#125; Thread.sleep(5000); ThreadA a=new ThreadA(); a.start(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:12345678在Main线程中取值=1495583100820在Main线程中取值=1495583100820在Main线程中取值=1495583100820在Main线程中取值=1495583100820在ThreadA线程中取值= 1495583106829在ThreadA线程中取值= 1495583106829在ThreadA线程中取值= 1495583106829在ThreadA线程中取值= 1495583106829 子线程和父线程各有各自所拥有的值 摘选自 java多线程核心编程技术-3.3]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>读书笔记</tag>
        <tag>threadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.7synchronized代码块有volatile同步的功能]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fsynchronized-block-has-volatile%2F</url>
    <content type="text"><![CDATA[关键字synchronized可以使多个线程访问同一资源具有同步性，而且它还具有将线程工作内存中的私有变量与公共内存中的变量同步的功能。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; private boolean isContinueRun=true; public void runMethod()&#123; while (isContinueRun==true)&#123; &#125; System.out.println("停下来了！"); &#125; public void stopMethod()&#123; isContinueRun=false; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Service service; public ThreadA(Service service) &#123; super(); this.service = service; &#125; @Override public void run() &#123; service.runMethod(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private Service service; public ThreadB(Service service) &#123; super(); this.service = service; &#125; @Override public void run() &#123; service.stopMethod(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; try&#123; Service service=new Service(); ThreadA a=new ThreadA(service); a.start(); Thread.sleep(1000); ThreadB b=new ThreadB(service); b.start(); System.out.println("已经发起停止的命令了！"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 以-server服务器模式运行此项目，出现死循环。程序的运行结果为:1已经发起停止的命令了！ 出现了死循环。得到这个结果是各线程间的数据值没有可视化造成的，而关键字synchronized可以具有可视化。 更改Service.java代码如下：123456789101112131415161718192021/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; private boolean isContinueRun=true; public void runMethod()&#123; String anyString=new String(); while (isContinueRun==true)&#123; synchronized (anyString)&#123; &#125; &#125; System.out.println("停下来了！"); &#125; public void stopMethod()&#123; isContinueRun=false; &#125;&#125; 再以-server服务器模式运行程序后可以正常退出。运行结果如下:12已经发起停止的命令了！停下来了！ 关键字synchronized可以保证在同一时刻，只有一个线程可以执行某个方法或某一个代码块。它包含两个特征：互斥性和可见性。同步synchronized不仅可以解决一个线程看到对象处于不一致的状态，还可以保证进入同步方法或者同步代码块的每个线程，都看到由同一个锁保护之前所有的修改效果。 学习多线程并发，要着重“外练互斥，内修可见”，这是掌握多线程、学习多线程并发的重要技术点。 摘选自 java多线程核心编程技术-2.3.7]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.6原子类也并不安全]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fatomic-class-not-safe%2F</url>
    <content type="text"><![CDATA[原子类在具有有逻辑性的情况下输出结果也具有随机性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * @author wuyoushan * @date 2017/4/19. */public class MyService &#123; public static AtomicLong atomicLong=new AtomicLong(); public void addNum()&#123; System.out.println(Thread.currentThread().getName()+"加了100之后的值是:" +atomicLong.addAndGet(100)); atomicLong.addAndGet(1); &#125;&#125;/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; private MyService myService; public MyThread(MyService myService) &#123; super(); this.myService = myService; &#125; @Override public void run() &#123; super.run(); myService.addNum(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; try&#123; MyService service=new MyService(); MyThread[] array=new MyThread[5]; for (int i = 0; i &lt; array.length; i++) &#123; array[i]=new MyThread(service); &#125; for (int i = 0; i &lt; array.length; i++) &#123; array[i].start(); &#125; Thread.sleep(1000); System.out.println(service.atomicLong.get()); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:123456Thread-2加了100之后的值是:100Thread-3加了100之后的值是:201Thread-4加了100之后的值是:502Thread-0加了100之后的值是:401Thread-1加了100之后的值是:301505 打印顺序出错了，应该是每加1次100再加1次1.出现这样的情况是因为addAndGet()方法是原子的，但方法和方法之间的调用却不是原子的。解决这样的问题必须要同步。 更改MyService.java文件代码如下:12345678910111213/** * @author wuyoushan * @date 2017/4/19. */public class MyService &#123; public static AtomicLong atomicLong=new AtomicLong(); synchronized public void addNum()&#123; System.out.println(Thread.currentThread().getName()+"加了100之后的值是:" +atomicLong.addAndGet(100)); atomicLong.addAndGet(1); &#125;&#125; 程序的运行结果为：123456Thread-0加了100之后的值是:100Thread-1加了100之后的值是:201Thread-2加了100之后的值是:302Thread-3加了100之后的值是:403Thread-4加了100之后的值是:504505 从运行的结果可以看到，是每次加100再加1，这就是我们想要得到的过程，结果505的同时还保证在过程中的累加的顺序也是正确的。 摘选自 java多线程核心编程技术-2.3.6]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.5使用原子类进行i++操作]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fatomic-classes-operations%2F</url>
    <content type="text"><![CDATA[除了在i++操作时使用synchronized关键字实现同步外，还可以使用AtomicInteger原子类进行实现 原子操作是不能分割的整体，没有其他线程能够中断或检查正在原子操作中的变量。一个原子类型就是一个原子操作可用的类型，它可以在没有锁的情况下做到线程安全1234567891011121314151617181920212223242526272829303132333435363738/** * @author wuyoushan * @date 2017/5/5. */public class AddCountThread extends Thread &#123; private AtomicInteger count =new AtomicInteger(0); @Override public void run() &#123; for (int i=0;i&lt;10000;i++)&#123; System.out.println(count.incrementAndGet()); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; AddCountThread countThread=new AddCountThread(); Thread t1=new Thread(countThread); t1.start(); Thread t2=new Thread(countThread); t2.start(); Thread t3=new Thread(countThread); t3.start(); Thread t4=new Thread(countThread); t4.start(); Thread t5=new Thread(countThread); t5.start(); &#125;&#125; 程序运行后，成功累加到50000123456749994499954999649997499984999950000 摘选自 java多线程核心编程技术-2.3.5]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.4非原子的特性]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fnonatomic-characteristics%2F</url>
    <content type="text"><![CDATA[关键字volatile虽然增加了实例变量在多个线程之间的可见性，但它却不具备同步性，那么也就不具备原子性。12345678910111213141516171819202122232425262728293031323334353637/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; volatile public static int count; private static void addCount()&#123; for (int i = 0; i &lt; 100; i++) &#123; count++; &#125; System.out.println("count="+count); &#125; @Override public void run() &#123; addCount(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; MyThread[] mythreadArray=new MyThread[100]; for (int i = 0; i &lt; 100; i++) &#123; mythreadArray[i]=new MyThread(); &#125; for (int i = 0; i &lt; 100; i++) &#123; mythreadArray[i].start(); &#125; &#125;&#125; 程序的运行结果为：123456count=3400count=3500count=3600count=9900count=9900count=9900 更改自定义线程类MyThread.java文件如下:12345678910111213141516171819202122232425/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; volatile public static int count; //注意一定要添加static关键字 //这样synchronized与static锁的内容就是MyThread.class类 //不使用static使用的是内置锁,会出现脏的输出，类似于上面的输出结果 //也就达到同步的效果了 synchronized private static void addCount()&#123; for (int i = 0; i &lt; 100; i++) &#123; count++; &#125; System.out.println("count="+count); &#125; @Override public void run() &#123; addCount(); &#125;&#125; 程序的运行效果为:12345count=9600count=9700count=9800count=9900count=10000 在上面的代码中，如果使用了private static void addCount()前加入synchronized同步关键字，也就没有必要再使用volatile关键字来声明count变量了。 关键字volatile主要使用场合是在多个线程中可以感知实例变量被更改了，并且可以获得最新的值使用，也就是用多线程读取共享变量是可以获取得最新值使用 关键字volatile提示线程每次从共享内存中读取变量，而不是从有的内存中读取，这样就保证了同步数据的可见性。但这里需要注意的是：如果修改实例变量中的数据，比如i++，也就是i=i+1，则这样的操作其实并不是一个原子操作。也就是非线程安全的。表达式i++的操作步骤分解如下： 从内存中取出i的值 计算i的值 将i的值写到内存中 假如在第2步计算值的时候，另外一个线程也修改i的值，那么这个时候就会出现脏数据。解决的办法其实就是使用synchronized关键字，这个知识点在前面的案例中已经介绍过了。所以说volatile本身并不处理数据的原子性，而是强制对数据的读写及时影响到主内存的。 对于用volatile修饰的变量，JVM虚拟机只是保证从主内存加载到线程工作内存的值是最新的。volatile关键字解决的是变量读时的可见性问题，但无法保证原子性，对于多个线程访问同一个实例变量还是需要加锁同步。 摘选自 java多线程核心编程技术-2.3.4]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.3解决异步死循环]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fasync-dead-loop%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author wuyoushan * @date 2017/5/3. */public class RunThread extends Thread &#123; private boolean isRuning=true; public boolean isRuning() &#123; return isRuning; &#125; public void setRuning(boolean runing) &#123; isRuning = runing; &#125; @Override public void run() &#123; System.out.println("进入run了"); while (isRuning==true)&#123; &#125; System.out.println("线程被停止了！"); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; try&#123; RunThread thread=new RunThread(); thread.start(); Thread.sleep(1000); thread.setRuning(false); System.out.println("已经赋值为false"); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为：123进入run了线程被停止了！已经赋值为false 如果将JVM的运行参数设置为-server程序的运行结果为:12进入run了已经赋值为false 代码“System.out.println(“线程被停止了！”)”从未被执行。是什么样的原因造成将JVM设置为-server时出现死循环呢？ 在启动RunThread.java线程时，变量private boolean isRunning=true;存在于公共堆栈及线程的私有栈中。在JVM被设置为-server模式时为了线程运行的效率，线程一直在私有堆栈中取得isRunning的值是true。而代码thread.setRunning(false);虽然被执行，更新的却是公共堆栈中的isRunning变量值false，所以一直就是死循环的状态。 这个问题其实就是私有堆栈中的值和公共堆栈中的值不同步造成的。解决这样的问题就要使用volatile关键字了，他的主要作用就是当线程访问isRunning这个变量时，强制性从公共堆栈中进行取值。123456789101112131415161718192021222324252627282930313233343536373839404142/** * @author wuyoushan * @date 2017/5/3. */public class RunThread extends Thread &#123; volatile private boolean isRuning=true; public boolean isRuning() &#123; return isRuning; &#125; public void setRuning(boolean runing) &#123; isRuning = runing; &#125; @Override public void run() &#123; System.out.println("进入run了"); while (isRuning==true)&#123; &#125; System.out.println("线程被停止了！"); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; try&#123; RunThread thread=new RunThread(); thread.start(); Thread.sleep(1000); thread.setRuning(false); System.out.println("已经赋值为false"); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:123进入run了线程被停止了！已经赋值为false 通过使用volatile关键字，强制的从公共内存中读取变量的值。 使用volatile关键字增加了实例变量在多个线程之间的可见性。但volatile关键字最致命的缺点是不支持原子性。 下面将关键字synchronized和volatile进行比较 关键字volatile是线程同步的轻量级实现，所以volatile性能肯定比synchronized要好，并且volatile只能修饰于变量，而synchronized可以修饰方法，以及代码块。随着JDK新版本的发布，synchronized关键字在执行效率上得到很大提升，在开发中使用synchronized关键字的比率还是比较大的。 多线程访问volatile不会发生阻塞，而synchronized会出现阻塞。 volatile能保证数据的可见性，但不能保证原子性；而synchronized可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步。 再次重申一下，关键字volatile解决的是变量在多个线程之间的可见性；而synchronized关键字解决的是多个线程之间访问资源的同步性。 线程安全包含原子性和可见性两个方面，java的同步机制都是围绕这两个方面来确保线程安全的。 摘选自 java多线程核心编程技术-2.3.3]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3.2解决同步死循环]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fsync-dead-loop%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @author wuyoushan * @date 2017/5/3. */public class PrintString implements Runnable&#123; private boolean isContinuePrint=true; public boolean isContinuePrint() &#123; return isContinuePrint; &#125; public void setContinuePrint(boolean continuePrint) &#123; isContinuePrint = continuePrint; &#125; public void printStringMethod()&#123; try &#123; while (isContinuePrint == true) &#123; System.out.println("run printStringMethod threadName=" + Thread.currentThread().getName()); Thread.sleep(1000); &#125; &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; printStringMethod(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; PrintString printStringService=new PrintString(); new Thread(printStringService).start(); System.out.println("我要停止它！stopThread="+Thread.currentThread().getName()); printStringService.setContinuePrint(false); &#125;&#125; 程序的运行结果为：12我要停止它！stopThread=mainrun printStringMethod threadName=Thread-0 但当上面的示例代码的格式运行在-server服务器模式中64bit的JVM上时，会出现死循环。解决的办法是使用volatile关键字 关键字volatile的作用是强制从公共堆栈中取得变量的值，而不是从线程私有数据栈中取得变量的值。 摘选自 java多线程核心编程技术-2.3.2]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3volatile关键字]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fvolatile-keyword%2F</url>
    <content type="text"><![CDATA[关键字volatile的主要作用是使变量在多个线程间可见。 关键字volatile与死循环如果不是在多继承的情况下，使用继承Thread类和实现Runable接口在取得程序运行的结果上并没有什么太大的区别。如果一旦出现“多继承”的情况，则用实现Runable接口的方式来处理多线程的问题就是很有必要的。 本节将用实现Runable接口的方式来继续理解多线程技术的使用，并且使用关键字volatile来实验在并发情况下的一些特性。此案例也同样适用于继承自Thread类12345678910111213141516171819202122232425262728293031323334353637383940/** * @author wuyoushan * @date 2017/5/3. */public class PrintString &#123; private boolean isContinuePrint=true; public boolean isContinuePrint() &#123; return isContinuePrint; &#125; public void setContinuePrint(boolean continuePrint) &#123; isContinuePrint = continuePrint; &#125; public void printStringMethod()&#123; try &#123; while (isContinuePrint == true) &#123; System.out.println("run printStringMethod threadName=" + Thread.currentThread().getName()); Thread.sleep(1000); &#125; &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; PrintString printStringService=new PrintString(); printStringService.printStringMethod(); System.out.println("我要停止它！stopThread="+Thread.currentThread().getName()); printStringService.setContinuePrint(false); &#125;&#125; 程序开始运行后，根本停不下来。结果如下:1234run printStringMethod threadName=mainrun printStringMethod threadName=mainrun printStringMethod threadName=mainrun printStringMethod threadName=main 停不下来的原因主要是main线程一直在处理while()循环，导致程序不能继续执行后面的代码，解决的办法当然就是多线程。 摘选自 java多线程核心编程技术-2.3]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.16锁对象的改变]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Flock-object-changes%2F</url>
    <content type="text"><![CDATA[在将任何数据类型作为同步锁时，需要注意的是，是否有多个线程同时持有锁对象，如果同时持有相同的锁对象，则这些线程之间就是同步的；如果分别获得锁对象，这些线程之间就是异步的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * @author wuyoushan * @date 2017/4/19. */public class MyService &#123; private String lock="123"; public void testMethod()&#123; try &#123; synchronized (lock) &#123; System.out.println(Thread.currentThread().getName() + " begin " + System.currentTimeMillis()); lock = "456"; Thread.sleep(2000); System.out.println(Thread.currentThread().getName() + " end " + System.currentTimeMillis()); &#125; &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private MyService service; public ThreadA(MyService service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.testMethod(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private MyService service; public ThreadB(MyService service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.testMethod(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) throws InterruptedException &#123; MyService service=new MyService(); ThreadA a=new ThreadA(service); a.setName("A"); ThreadB b=new ThreadB(service); b.setName("B"); a.start(); Thread.sleep(50); b.start(); &#125;&#125; 程序运行后的结果为:1234A begin 1493684592096B begin 1493684592146A end 1493684594096B end 1493684594146 程序的结果是异步输出的。因为50毫秒过后B取得的锁是“456” 12345678910111213141516/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) throws InterruptedException &#123; MyService service=new MyService(); ThreadA a=new ThreadA(service); a.setName("A"); ThreadB b=new ThreadB(service); b.setName("B"); a.start();// Thread.sleep(50); b.start(); &#125;&#125; 去掉Thread.sleep(50)，程序的运行结果如下:1234A begin 1493685002103A end 1493685004104B begin 1493685004104B end 1493685006104 线程A和B持有的锁都是“123”，虽然将锁改成了“456”，但是结果还是同步的，因为A和B共同争抢的锁是“123”。 还需要提示一下，只要对象不变，即使对象的属性被改变，运行的结果还是同步。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; public void serviceMethodA(UserInfo userInfo)&#123; synchronized (userInfo)&#123; try &#123; System.out.println(Thread.currentThread().getName()); userInfo.setUserName("abcabcabc"); Thread.sleep(3000); System.out.println("end! time="+System.currentTimeMillis()); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Service service; private UserInfo userInfo; public ThreadA(Service service,UserInfo userInfo) &#123; super(); this.service = service; this.userInfo=userInfo; &#125; @Override public void run() &#123; super.run(); service.serviceMethodA(userInfo); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private Service service; private UserInfo userInfo; public ThreadB(Service service,UserInfo userInfo) &#123; this.service = service; this.userInfo=userInfo; &#125; @Override public void run() &#123; super.run(); service.serviceMethodA(userInfo); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; try &#123; Service service = new Service(); UserInfo userInfo = new UserInfo(); ThreadA a = new ThreadA(service, userInfo); a.setName("a"); a.start(); Thread.sleep(50); ThreadB b = new ThreadB(service, userInfo); b.setName("b"); b.start(); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为：1234aend! time=1493685934399bend! time=1493685937399 摘选自 java多线程核心编程技术-2.2.16]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.15内置类与同步：实验2]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fin-class-and-sync-two%2F</url>
    <content type="text"><![CDATA[本实验测试同步代码块synchronized(class2)对class2上锁后，其他线程只能以同步的方式调用class2中的静态同步方法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * @author wuyoushan * @date 2017/4/28. */public class OutClass &#123; static class InnerClass1&#123; public void method1(InnerClass2 class2)&#123; String threadName=Thread.currentThread().getName(); synchronized (class2)&#123; System.out.println(threadName+" 进入InnerClass1类中的method1方法"); for (int i = 1; i &lt; 10 ; i++) &#123; System.out.println(Thread.currentThread().getName()+" i="+i); try&#123; Thread.sleep(100); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; System.out.println(threadName+" 离开InnerClass1类中的method1方法"); &#125; &#125; public synchronized void method2()&#123; String threadName=Thread.currentThread().getName(); System.out.println(threadName+" 进入InnerClass1类中的method2方法"); for (int j = 0; j &lt;10; j++) &#123; System.out.println("j="+j); try&#123; Thread.sleep(100); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; System.out.println(threadName+" 离开InnerClass1类中的method2方法"); &#125; &#125; static class InnerClass2&#123; public synchronized void method1()&#123; String threadName=Thread.currentThread().getName(); System.out.println(threadName+" 进入InnerClass2类中的method1方法"); for (int k = 0; k &lt; 10; k++) &#123; System.out.println("k="+k); try&#123; Thread.sleep(100); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; System.out.println(threadName+" 离开InnerClass2类中的method1方法"); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; final OutClass.InnerClass1 in1=new OutClass.InnerClass1(); final OutClass.InnerClass2 in2=new OutClass.InnerClass2(); Thread t1=new Thread(new Runnable() &#123; @Override public void run() &#123; in1.method1(in2); &#125; &#125;,"T1"); Thread t2=new Thread(new Runnable() &#123; @Override public void run() &#123; in1.method2(); &#125; &#125;,"T2"); Thread t3=new Thread(new Runnable() &#123; @Override public void run() &#123; in2.method1(); &#125; &#125;,"T3"); t1.start(); t2.start(); t3.start(); &#125;&#125; 程序的运行结果为：12345678910T1 进入InnerClass1类中的method1方法T2 进入InnerClass1类中的method2方法T1 i=1j=0T1 i=2....T1 离开InnerClass1类中的method1方法T3 进入InnerClass2类中的method1方法j=9k=0 摘选自 java多线程核心编程技术-2.2.15]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.14内置类与同步：实验1]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fin-class-and-sync%2F</url>
    <content type="text"><![CDATA[本实验测试的案例是在内置类中有两个同步方法，但使用的却是不同的锁，打印的结果也是异步的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * @author wuyoushan * @date 2017/4/28. */public class OutClass &#123; static class Inner&#123; public void method1()&#123; synchronized ("其他的锁")&#123; for (int i = 1; i &lt;=10 ; i++) &#123; System.out.println(Thread.currentThread().getName()+" i="+i); try&#123; Thread.sleep(100); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public synchronized void method2()&#123; for (int i = 11; i &lt;=20; i++) &#123; System.out.println(Thread.currentThread().getName()+" i="+i); try&#123; Thread.sleep(100); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; final OutClass.Inner inner=new OutClass.Inner(); Thread t1=new Thread(new Runnable() &#123; @Override public void run() &#123; inner.method1(); &#125; &#125;,"A"); Thread t2=new Thread(new Runnable() &#123; @Override public void run() &#123; inner.method2(); &#125; &#125;,"B"); t1.start(); t2.start(); &#125;&#125; 程序的运行结果为：12345B i=14B i=15A i=5A i=6B i=16 由于持有不同的“对象监视器”，所以打印结果就是乱序的。 摘选自 java多线程核心编程技术-2.2.14]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.13内置类与静态内置类]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fin-class-with-static-in-class%2F</url>
    <content type="text"><![CDATA[关键字synchronized的知识点还涉及内置类的使用。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * @author wuyoushan * @date 2017/4/27. */public class PublicClass &#123; private String username; private String password; class PrivateClass&#123; private String age; private String address; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; PublicClass publicClass=new PublicClass(); publicClass.setUsername("usernameValue"); publicClass.setPassword("passwordValue"); System.out.println(publicClass.getUsername()+" "+publicClass.getPassword()); PublicClass.PrivateClass privateClass=publicClass.new PrivateClass(); privateClass.setAge("ageValue"); privateClass.setAddress("addressValue"); System.out.println(privateClass.getAge()+" "+privateClass.getAddress()); &#125;&#125; 程序的运行结果为：12usernameValue passwordValueageValue addressValue 如果PublicClass.java类和Run.java类不在同一个包中，则需要将PrivateClass内置声明成public公开的。 想要实例化内置类必须使用如下代码:1PublicClass.PrivateClass privateClass=publicClass.new PrivateClass(); 内置类还有一种叫作静态内置类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263** * @author wuyoushan * @date 2017/4/27. */public class PublicClass &#123; private String username; private String password; static class PrivateClass&#123; private String age; private String address; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = age; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; PublicClass publicClass=new PublicClass(); publicClass.setUsername("usernameValue"); publicClass.setPassword("passwordValue"); System.out.println(publicClass.getUsername()+" "+publicClass.getPassword()); PublicClass.PrivateClass privateClass=new PublicClass.PrivateClass(); privateClass.setAge("ageValue"); privateClass.setAddress("addressValue"); System.out.println(privateClass.getAge()+" "+privateClass.getAddress()); &#125;&#125; 程序的运行结果为：12usernameValue passwordValueageValue addressValue 摘选自 java多线程核心编程技术-2.2.13]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.12多线程的死锁]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fthread-dead-lock%2F</url>
    <content type="text"><![CDATA[java线程死锁是一个经典的问题，因为不同的线程都在等待根本不可能被释放的锁，从而导致所有的任务都无法继续完成。在多线程技术中，“死锁”是必须避免的，因为这会造成线程的“假死”1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/** * @author wuyoushan * @date 2017/4/25. */public class DealThread implements Runnable &#123; public String username; public Object lock1=new Object(); public Object lock2=new Object(); public void setFlag(String username)&#123; this.username=username; &#125; @Override public void run() &#123; if (username.equals("a"))&#123; synchronized (lock1)&#123; try&#123; System.out.println("username="+username); Thread.sleep(3000); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; synchronized (lock2)&#123; System.out.println("按lock1-&gt;lock2代码顺序执行了"); &#125; &#125; &#125; if (username.equals("b"))&#123; synchronized (lock2)&#123; try&#123; System.out.println("username="+username); Thread.sleep(3000); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; synchronized (lock1)&#123; System.out.println("按lock2-&gt;lock1代码顺序执行了"); &#125; &#125; &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; try &#123; DealThread t1=new DealThread(); t1.setFlag("a"); Thread thread1=new Thread(t1); thread1.start(); Thread.sleep(100); t1.setFlag("b"); Thread thread2=new Thread(t1); thread2.start(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为：12username=ausername=b 死锁是程序设计的bug，在设计程序时就要避免双方互相持有对方的锁情况。需要说明的是，本实验使用synchronized嵌套的代码结构来实现死锁，其实不使用嵌套的synchronized代码结构也会出现死锁，与嵌套不嵌套无任何关系，不要被代码结构所误导。只要互相等待对方释放锁就有可能出现死锁。 摘选自 java多线程核心编程技术-2.2.12]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.11同步synchronized方法无限等待与解决]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fsynchronized-method-wait-and-fix%2F</url>
    <content type="text"><![CDATA[同步方法易造成死循环1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; synchronized public void methodA()&#123; System.out.println("methodA begin"); boolean isContinueRun=true; while (isContinueRun)&#123; &#125; System.out.println("methodA end"); &#125; synchronized public void methodB()&#123; System.out.println("methodB begin"); System.out.println("methodB end"); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Service service; public ThreadA(Service service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.methodA(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private Service service; public ThreadB(Service service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.methodB(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; Service service=new Service(); ThreadA a=new ThreadA(service); a.start(); ThreadB b=new ThreadB(service); b.start(); &#125;&#125; 程序的运行结果为：1methodA begin 线程B永远得不到运行的机会，锁死了。这时候可以用同步块来解决这样的问题。更改Service.java文件代码如下:123456789101112131415161718192021222324/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; Object object1=new Object(); public void methodA()&#123; synchronized (object1) &#123; System.out.println("methodA begin"); boolean isContinueRun = true; while (isContinueRun) &#123; &#125; System.out.println("methodA end"); &#125; &#125; Object object2=new Object(); public void methodB()&#123; synchronized (object2) &#123; System.out.println("methodB begin"); System.out.println("methodB end"); &#125; &#125;&#125; 程序的运行结果为：123methodA beginmethodB beginmethodB end 摘选自 java多线程核心编程技术-2.2.11]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.10数据类型String的常量池特性]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fstring-constant-pool%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; public static void print(String stringParam)&#123; try&#123; synchronized (stringParam) &#123; while (true) &#123; System.out.println(Thread.currentThread().getName()); Thread.sleep(1000); &#125; &#125; &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Service service; public ThreadA(Service service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.print("AA"); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private Service service; public ThreadB(Service service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.print("AA"); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; Service service=new Service(); ThreadA a=new ThreadA(service); a.setName("A"); a.start(); ThreadB b=new ThreadB(service); b.setName("B"); b.start(); &#125;&#125; 程序的运行结果为：1234AAAA 出现这样的情况就是因为String的两个值都是AA，两个线程持有相同的锁，所以造成线程B不能执行。这就是String常量池所带来的问题。因此在大多数情况下，同步synchronized代码块都不使用String作为锁对象，而改用其他，比如new Object()实例化一个Object对象，但它并不放入缓存中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; public static void print(Object object)&#123; try&#123; synchronized (object) &#123; while (true) &#123; System.out.println(Thread.currentThread().getName()); Thread.sleep(1000); &#125; &#125; &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Service service; public ThreadA(Service service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.print(new Object()); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private Service service; public ThreadB(Service service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.print(new Object()); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; Service service=new Service(); ThreadA a=new ThreadA(service); a.setName("A"); a.start(); ThreadB b=new ThreadB(service); b.setName("B"); b.start(); &#125;&#125; 程序的运行结果为：12345678910ABABBABABA 交替打印的原因是持有的锁不是一个。 摘选自 java多线程核心编程技术-2.2.10]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.9静态同步synchronized方法与synchronized(class)代码块]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fstatic-synchronized-method%2F</url>
    <content type="text"><![CDATA[synchronized还可以应用在static静态方法上，如果这样写，那是对当前的*.java文件对应的Class类进行持锁。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; synchronized public static void printA()&#123; try&#123; System.out.println("线程名称为："+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"进入printA"); Thread.sleep(3000); System.out.println("线程名称为："+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"离开printB"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; synchronized public static void printB()&#123; System.out.println("线程名称为："+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"进入printA"); System.out.println("线程名称为："+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"离开printB"); &#125;&#125; * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; @Override public void run() &#123; super.run(); Service.printA(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; @Override public void run() &#123; super.run(); Service.printB(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; ThreadA a=new ThreadA(); a.setName("A"); a.start(); ThreadB b=new ThreadB(); b.setName("B"); b.start(); &#125;&#125; 程序的运行结果为：1234线程名称为：A在1492993790410进入printA线程名称为：A在1492993793410离开printA线程名称为：B在1492993793410进入printB线程名称为：B在1492993793410离开printB 从运行的结果来看，并没有什么特别之处，都是同步的效果，和将synchronized关键字加到static方法上使用的效果是一样的。其实还是有本子上的不同的，synchronized关键字加到static静态方法是是给Class类上锁的，而synchronized关键字加到非static静态方法上是给对象上锁。 验证不是同一个锁123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; synchronized public static void printA()&#123; try&#123; System.out.println("线程名称为："+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"进入printA"); Thread.sleep(3000); System.out.println("线程名称为："+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"离开printA"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; synchronized public static void printB()&#123; System.out.println("线程名称为："+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"进入printB"); System.out.println("线程名称为："+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"离开printB"); &#125; synchronized public void printC()&#123; System.out.println("线程名称为："+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"进入printC"); System.out.println("线程名称为："+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"离开printC"); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Service service; public ThreadA(Service service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.printA(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private Service service; public ThreadB(Service service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.printB(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadC extends Thread&#123; private Service service; public ThreadC(Service service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.printC(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; Service service=new Service(); ThreadA a=new ThreadA(service); a.setName("A"); a.start(); ThreadB b=new ThreadB(service); b.setName("B"); b.start(); ThreadC c=new ThreadC(service); c.setName("C"); c.start(); &#125;&#125; 程序的运行结果为：123456线程名称为：B在1492994339480进入printB线程名称为：B在1492994339480离开printB线程名称为：A在1492994339482进入printA线程名称为：C在1492994339482进入printC线程名称为：C在1492994339482离开printC线程名称为：A在1492994342482离开printA 异步的原因是持有不同的锁，一个是对象锁，另外一个是Class锁，而Class锁可以对类的所有对象实例起作用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; synchronized public static void printA()&#123; try&#123; System.out.println("线程名称为："+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"进入printA"); Thread.sleep(3000); System.out.println("线程名称为："+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"离开printA"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; synchronized public static void printB()&#123; System.out.println("线程名称为："+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"进入printB"); System.out.println("线程名称为："+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"离开printB"); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Service service; public ThreadA(Service service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.printA(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private Service service; public ThreadB(Service service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.printB(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; Service service1=new Service(); Service service2=new Service(); ThreadA a=new ThreadA(service1); a.setName("A"); a.start(); ThreadB b=new ThreadB(service2); b.setName("B"); b.start(); &#125;&#125; 程序的运行结果为：1234线程名称为：A在1492995107179进入printA线程名称为：A在1492995110186离开printA线程名称为：B在1492995110186进入printB线程名称为：B在1492995110186离开printB 同步synchronized(class)代码块的作用其实和synchronized static方法的作用一样。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; public static void printA()&#123; synchronized (Service.class)&#123; try &#123; System.out.println("线程名称为：" + Thread.currentThread().getName() + "在" + System.currentTimeMillis() + "进入printA"); Thread.sleep(3000); System.out.println("线程名称为：" + Thread.currentThread().getName() + "在" + System.currentTimeMillis() + "离开printA"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void printB() &#123; synchronized (Service.class) &#123; System.out.println("线程名称为：" + Thread.currentThread().getName() + "在" + System.currentTimeMillis() + "进入printB"); System.out.println("线程名称为：" + Thread.currentThread().getName() + "在" + System.currentTimeMillis() + "离开printB"); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Service service; public ThreadA(Service service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.printA(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private Service service; public ThreadB(Service service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.printB(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; Service service1=new Service(); Service service2=new Service(); ThreadA a=new ThreadA(service1); a.setName("A"); a.start(); ThreadB b=new ThreadB(service2); b.setName("B"); b.start(); &#125;&#125; 程序的运行结果为：1234线程名称为：A在1492995444496进入printA线程名称为：A在1492995447497离开printA线程名称为：B在1492995447497进入printB线程名称为：B在1492995447497离开printB 摘选自 java多线程核心编程技术-2.2.9]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.8细化验证3个结论]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fverify-three-ending%2F</url>
    <content type="text"><![CDATA[“synchronized(非this对象x)”格式的写法是将x对象本身作为“对象监视器”，这样就可以得出以下3个结论： 当多个线程同时执行synchronized(x){}同步代码块时呈同步效果 当其他线程执行x对象中synchronized同步方法时呈同步效果 当其他线程执行x对象方法里面的synchronized(this)代码块时也呈现同步效果 但需要注意：如果其他线程调用不加synchronized关键字的方法时，还是异步调用。 当多个线程同时执行synchronized(x){}同步代码块时呈同步效果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/** * @author wuyoushan * @date 2017/3/29. */public class MyObject &#123;&#125;/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; public void testMethod1(MyObject object)&#123; synchronized (object)&#123; try&#123; System.out.println("testMethod1 getLock time=" +System.currentTimeMillis()+"run ThreadName=" +Thread.currentThread().getName()); Thread.sleep(2000); System.out.println("testMethod1 releaseLock time=" +System.currentTimeMillis()+"run ThreadName=" +Thread.currentThread().getName()); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Service service; private MyObject object; public ThreadA(Service service, MyObject object) &#123; super(); this.service = service; this.object = object; &#125; @Override public void run() &#123; super.run(); service.testMethod1(object); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private Service service; private MyObject object; public ThreadB(Service service, MyObject object) &#123; super(); this.service = service; this.object = object; &#125; @Override public void run() &#123; super.run(); service.testMethod1(object); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) throws InterruptedException &#123; Service service=new Service(); MyObject object=new MyObject(); ThreadA a=new ThreadA(service,object); a.setName("a"); a.start(); ThreadB b=new ThreadB(service,object); b.setName("b"); b.start(); &#125;&#125; 程序的运行结果是：1234testMethod1 getLock time=1492734868657run ThreadName=atestMethod1 releaseLock time=1492734870658run ThreadName=atestMethod1 getLock time=1492734870658run ThreadName=btestMethod1 releaseLock time=1492734872658run ThreadName=b 同步的原因是使用了同一个“对象监视器”。如果使用不同的“对象监视器”会出现什么样的效果呢？ 修改类文件Run.java，代码如下：1234567891011121314151617/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) throws InterruptedException &#123; Service service=new Service(); MyObject object1=new MyObject(); MyObject object2=new MyObject(); ThreadA a=new ThreadA(service,object1); a.setName("a"); a.start(); ThreadB b=new ThreadB(service,object2); b.setName("b"); b.start(); &#125;&#125; 运行结果为:1234testMethod1 getLock time=1492735877980run ThreadName=atestMethod1 getLock time=1492735877981run ThreadName=btestMethod1 releaseLock time=1492735879982run ThreadName=btestMethod1 releaseLock time=1492735879982run ThreadName=a 当其他线程执行x对象中synchronized同步方法时呈同步效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/** * @author wuyoushan * @date 2017/3/29. */public class MyObject &#123; synchronized public void speedPrintString()&#123; System.out.println("speedPrintString getLock time=" +System.currentTimeMillis()+"run ThreadName=" +Thread.currentThread().getName()); System.out.println("--------------------"); System.out.println("speedPrintString releaseLock time=" +System.currentTimeMillis()+"run ThreadName=" +Thread.currentThread().getName()); &#125;&#125;/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; public void testMethod1(MyObject object)&#123; synchronized (object)&#123; try&#123; System.out.println("testMethod1 getLock time=" +System.currentTimeMillis()+"run ThreadName=" +Thread.currentThread().getName()); Thread.sleep(5000); System.out.println("testMethod1 releaseLock time=" +System.currentTimeMillis()+"run ThreadName=" +Thread.currentThread().getName()); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Service service; private MyObject object; public ThreadA(Service service, MyObject object) &#123; super(); this.service = service; this.object = object; &#125; @Override public void run() &#123; super.run(); service.testMethod1(object); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private MyObject object; public ThreadB(MyObject object) &#123; super(); this.object = object; &#125; @Override public void run() &#123; super.run(); object.speedPrintString(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) throws InterruptedException &#123; Service service=new Service(); MyObject object=new MyObject(); ThreadA a=new ThreadA(service,object); a.setName("a"); a.start(); Thread.sleep(100); ThreadB b=new ThreadB(object); b.setName("b"); b.start(); &#125;&#125; 程序的运行结果为:12345testMethod1 getLock time=1492736535766run ThreadName=atestMethod1 releaseLock time=1492736540766run ThreadName=aspeedPrintString getLock time=1492736540766run ThreadName=b--------------------speedPrintString releaseLock time=1492736540766run ThreadName=b 验证第3个结论当其他线程执行x对象方法里面的synchronized(this)代码块时也呈现同步效果。修改MyObject.java的类，代码如下。123456789101112131415161718/** * @author wuyoushan * @date 2017/3/29. */public class MyObject &#123; synchronized public void speedPrintString()&#123; synchronized (this) &#123; System.out.println("speedPrintString getLock time=" + System.currentTimeMillis() + "run ThreadName=" + Thread.currentThread().getName()); System.out.println("--------------------"); System.out.println("speedPrintString releaseLock time=" + System.currentTimeMillis() + "run ThreadName=" + Thread.currentThread().getName()); &#125; &#125;&#125; 代码的运行结果如下:12345testMethod1 getLock time=1492916942775run ThreadName=atestMethod1 releaseLock time=1492916947775run ThreadName=aspeedPrintString getLock time=1492916947775run ThreadName=b--------------------speedPrintString releaseLock time=1492916947775run ThreadName=b 摘选自 java多线程核心编程技术-2.2.8]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.7将任意对象作为对象监视器]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fobject-as-monitor%2F</url>
    <content type="text"><![CDATA[多个线程调用同一个对象中的不同名称的synchronized同步方法或synchronized(this)同步代码块时，调用的效果就是按顺序执行，也就是同步的，阻塞的。这说明synchronized同步方法或synchronized(this)同步代码块分别有两种作用。 synchronized同步方法synchronized同步方法或synchronized(this)同步代码块调用呈阻塞状态。同一时间只有一个线程可以执行synchronized同步方法中的代码 synchronized(this)同步代码块对其他synchronized同步方法或synchronized(this)同步代码块调用呈阻塞状态同一时间只有一个线程可以执行synchronized(this)同步代码块中的代码 在前面的学习中，使用synchronized(this)格式同步代码块，其实java还支持对“任意对象”作为“对象监听器”来实现同步的功能。这个“任意对象”大多数是实例变量及方法的参数，使用格式为synchronized(非this对象) 根据前面对synchronized(this)同步代码块的作用总结可知，synchronized(非this对象)格式的作用只有1种：synchronized(非this对象x)同步代码块中的代码 当持有“对象监视器”为同一个对象的前提下，同一时间只有一个线程可以执行synchronized(非this对象x)同步代码块中的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; private String usernameParam; private String passwordParam; private String anyString=new String(); public void setUsernamePassword(String username,String password) &#123; try&#123; synchronized (anyString)&#123; System.out.println("线程名称为:"+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"进入同步块"); usernameParam=username; Thread.sleep(3000); passwordParam=password; System.out.println("线程名称为:"+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"离开同步块"); &#125; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Service service; public ThreadA(Service service)&#123; super(); this.service=service; &#125; @Override public void run() &#123; service.setUsernamePassword("a","aa"); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private Service service; public ThreadB(Service service)&#123; super(); this.service=service; &#125; @Override public void run() &#123; service.setUsernamePassword("b","bb"); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; Service service=new Service(); ThreadA a=new ThreadA(service); a.setName("A"); a.start(); ThreadB b=new ThreadB(service); b.setName("B"); b.start(); &#125;&#125; 程序的运行结果为:123456线程名称为:A在1492391031020进入同步块线程名称为:A在1492391034020离开同步块username:a password:aa线程名称为:B在1492391034020进入同步块线程名称为:B在1492391037020离开同步块username:b password:bb 锁非this对象具有一定的优点：如果在一个类中有很多个synchronized方法，这是虽然能实现同步，但会受到阻塞，所以影响运行效率；但如果使用同步代码块锁非this对象，则synchronized(非this)代码块中的程序与同步方法是异步的，不与其他锁this同步方法争抢this锁，则可大大提升运行效率。 将Service.java文件代码更改如下:123456789101112131415161718192021222324252627/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; private String usernameParam; private String passwordParam; public void setUsernamePassword(String username,String password) &#123; try&#123; String anyString=new String(); synchronized (anyString)&#123; System.out.println("线程名称为:"+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"进入同步块"); usernameParam=username; Thread.sleep(3000); passwordParam=password; System.out.println("线程名称为:"+Thread.currentThread().getName() +"在"+System.currentTimeMillis()+"离开同步块"); System.out.println("username:"+usernameParam+" password:"+passwordParam); &#125; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果如下所示:123456线程名称为:A在1492474468701进入同步块线程名称为:B在1492474468702进入同步块线程名称为:A在1492474471702离开同步块username:b password:aa线程名称为:B在1492474471702离开同步块username:b password:bb 可见，使用“synchronized(非this对象x)同步代码块”格式进行同步操作时，对象监视器必须是同一个对象。如果不是同一个对象监视器，运行的结果就是异步调用了，就会交叉运行。 下面我们再用另外一个项目来验证一下使用“synchronized(非this对象x)同步代码块”格式时，持有不同的对象监听器时异步的效果。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; private String anyString=new String(); public void a() &#123; try&#123; synchronized (anyString)&#123; System.out.println("a begin"); Thread.sleep(3000); System.out.println("a end"); &#125; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; synchronized public void b() &#123; System.out.println("b begin"); System.out.println("b end"); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Service service; public ThreadA(Service service)&#123; super(); this.service=service; &#125; @Override public void run() &#123; service.a(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private Service service; public ThreadB(Service service)&#123; super(); this.service=service; &#125; @Override public void run() &#123; service.b(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; Service service=new Service(); ThreadA a=new ThreadA(service); a.setName("A"); a.start(); ThreadB b=new ThreadB(service); b.setName("B"); b.start(); &#125;&#125; 程序的运行结果为:1234a beginb beginb enda end 由于对象监视器的不同，所以运行结果就是异步的。同步代码块放在非同步synchronized方法中进行声明，并不能保证调用方法的线程执行同步/顺序性，也就是线程调用方法的顺序是无序的，虽然在同步代码块中执行的顺序是同步的，这样极易出现“脏读”问题。 使用“synchronized(非this对象x)同步代码块”格式也可以解决“脏读”问题。但在解决脏读问题之前，先做一个实验，实验的目标是验证多个线程调用同一个方法是随机的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * @author wuyoushan * @date 2017/2/5. */public class MyList&#123; private List list=new ArrayList(); synchronized public void add(String username)&#123; System.out.println("ThreadName="+Thread.currentThread().getName() +"执行了add方法"); list.add(username); System.out.println("ThreadName="+Thread.currentThread().getName() +"退出了add方法"); &#125; synchronized public int getSize()&#123; System.out.println("ThreadName="+Thread.currentThread().getName() +"执行了getSize方法"); int sizeValue=list.size(); System.out.println("ThreadName="+Thread.currentThread().getName() +"退出了getSize方法"); return sizeValue; &#125;&#125;/** * @author wuyoushan * @date 2017/2/5. */public class ThreadA extends Thread&#123; private MyList list; public ThreadA( MyList list) &#123; super(); this.list = list; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; list.add("threadA"+(i+1)); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/2/5. */public class ThreadB extends Thread &#123; private MyList list; public ThreadB( MyList list) &#123; super(); this.list = list; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 1000; i++) &#123; list.add("threadA"+(i+1)); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/2/5. */public class Run &#123; public static void main(String[] args) &#123; MyList myList=new MyList(); ThreadA a=new ThreadA(myList); a.setName("A"); a.start(); ThreadB b=new ThreadB(myList); b.setName("B"); b.start(); &#125;&#125; 程序运行后的结果如下:123456ThreadName=B执行了add方法ThreadName=B退出了add方法ThreadName=A执行了add方法ThreadName=A退出了add方法ThreadName=B执行了add方法ThreadName=B退出了add方法 从运行的结果来看，同步代码块中的代码是同步打印的，当前线程的“执行”与“退出”是成对出现的。但线程A和线程B的执行却是异步的，这就有可能出现脏读的环境。由于线程执行方法的顺序不确定，所以当A和B两个线程执行带有分支判断的方法时，就会出现逻辑上的错误，有可能出现脏读。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091/** * @author wuyoushan * @date 2017/4/19. */public class MyOneList &#123; private List&lt;String&gt; list=new ArrayList&lt;&gt;(); synchronized public void add(String data)&#123; list.add(data); &#125; synchronized public int getSzie()&#123; return list.size(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/19. */public class MyService &#123; public MyOneList addServiceMethod(MyOneList list,String data)&#123; try&#123; if(list.getSzie()&lt;1)&#123; Thread.sleep(2000); //模拟从远程花费2秒取回数据 list.add(data); &#125; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; return list; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private MyOneList list; public ThreadA(MyOneList list)&#123; super(); this.list=list; &#125; @Override public void run() &#123; MyService service=new MyService(); service.addServiceMethod(list,"A"); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private MyOneList list; public ThreadB(MyOneList list)&#123; super(); this.list=list; &#125; @Override public void run() &#123; MyService service=new MyService(); service.addServiceMethod(list,"B"); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) throws InterruptedException &#123; MyOneList list=new MyOneList(); ThreadA a=new ThreadA(list); a.setName("A"); a.start(); ThreadB b=new ThreadB(list); b.setName("B"); b.start(); Thread.sleep(6000); System.out.println("listSize="+list.getSzie()); &#125;&#125; 程序运行后的结果为:1listSize=2 脏读出现了。出现的原因是两个线程以异步的方式返回list参数的size()大小。解决办法就是“同步化”更改MyService.java类文件代码：12345678910111213141516171819/** * @author wuyoushan * @date 2017/4/19. */public class MyService &#123; public MyOneList addServiceMethod(MyOneList list,String data)&#123; try&#123; synchronized (list) &#123; if (list.getSzie() &lt; 1) &#123; Thread.sleep(2000); //模拟从远程花费2秒取回数据 list.add(data); &#125; &#125; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; return list; &#125;&#125; 由于list参数对象在项目中是一份实例，是单例的，而且也正需要对list参数的getSize()方法做同步的调用，所以就对list参数进行同步处理。程序的运行结果为:1listSize=1 摘选自 java多线程核心编程技术-2.2.7]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.6验证同步synchronized(this)代码块是锁定当前对象的]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F23%2Fsynchronized-lock-current-obj%2F</url>
    <content type="text"><![CDATA[和synchronized方法一样，synchronized(this)代码块也是锁定当前对象的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * @author wuyoushan * @date 2017/3/14. */public class Task &#123; public void otherMethod()&#123; System.out.println("------------------run--otherMethod"); &#125; public void doLongTimeTask()&#123; synchronized (this)&#123; for (int i = 0; i &lt;1000 ; i++) &#123; System.out.println("synchronized threadName=" +Thread.currentThread().getName()+" i="+(i+1)); &#125; &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Task task; public ThreadA(Task task)&#123; super(); this.task=task; &#125; @Override public void run() &#123; super.run(); task.doLongTimeTask(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private Task task; public ThreadB(Task task)&#123; super(); this.task=task; &#125; @Override public void run() &#123; super.run(); task.otherMethod(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) throws InterruptedException &#123; Task task=new Task(); ThreadA a=new ThreadA(task); a.start(); Thread.sleep(10); ThreadB b=new ThreadB(task); b.start(); &#125;&#125; 程序运行结果如下:1234567synchronized threadName=Thread-0 i=212synchronized threadName=Thread-0 i=213synchronized threadName=Thread-0 i=214------------------run--otherMethodsynchronized threadName=Thread-0 i=215synchronized threadName=Thread-0 i=216synchronized threadName=Thread-0 i=217 运行的结果为异步的。修改Task.java如下：1234567891011121314151617/** * @author wuyoushan * @date 2017/3/14. */public class Task &#123; synchronized public void otherMethod()&#123; System.out.println("------------------run--otherMethod"); &#125; public void doLongTimeTask()&#123; synchronized (this)&#123; for (int i = 0; i &lt;1000 ; i++) &#123; System.out.println("synchronized threadName=" +Thread.currentThread().getName()+" i="+(i+1)); &#125; &#125; &#125;&#125; 运行结果如下:12345synchronized threadName=Thread-0 i=997synchronized threadName=Thread-0 i=998synchronized threadName=Thread-0 i=999synchronized threadName=Thread-0 i=1000------------------run--otherMethod 从上结果可知运行结果是同步的。 摘选自 java多线程核心编程技术-2.2.6]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.5synchronized代码块间的同步性]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F18%2Fsynchronized-synchronization%2F</url>
    <content type="text"><![CDATA[代码块的访问将被阻塞，这说明synchronized使用的“对象监视器”是一个。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * @author wuyoushan * @date 2017/4/14. */public class ObjectService &#123; public void serviceMethodA()&#123; try&#123; synchronized (this)&#123; System.out.println("A begin time="+System.currentTimeMillis()); Thread.sleep(2000); System.out.println("A end end="+System.currentTimeMillis()); &#125; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; public void serviceMethodB()&#123; synchronized (this)&#123; System.out.println("B begin time="+System.currentTimeMillis()); System.out.println("B end end="+System.currentTimeMillis()); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private ObjectService objectService; public ThreadA(ObjectService objectService)&#123; super(); this.objectService=objectService; &#125; @Override public void run() &#123; super.run(); objectService.serviceMethodA(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private ObjectService objectService; public ThreadB(ObjectService objectService)&#123; super(); this.objectService=objectService; &#125; @Override public void run() &#123; super.run(); objectService.serviceMethodB(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; ObjectService objectService=new ObjectService(); ThreadA a=new ThreadA(objectService); a.setName("a"); a.start(); ThreadB b=new ThreadB(objectService); b.setName("b"); b.start(); &#125;&#125; 程序的运行结果为：1234A begin time=1492130124674A end end=1492130126675B begin time=1492130126675B end end=1492130126675 synchronized(this)代码块是锁定当前对象的 摘选自 java多线程核心编程技术-2.2.5]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.4一半同步，一半异步]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F18%2Fhalf-sync-half-asynchronously%2F</url>
    <content type="text"><![CDATA[本实验要说明：不在synchronized块中就是异步执行，在synchronized块中就是同步执行123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * @author wuyoushan * @date 2017/1/23. */public class Task &#123; public void doLongTimeTask()&#123; for(int i=0;i&lt;100;i++)&#123; System.out.println("nosynchronized threadName= " +Thread.currentThread().getName()+" i= "+(i+1)); &#125; System.out.println(""); synchronized (this)&#123; for(int i=0;i&lt;100;i++)&#123; System.out.println("synchronized threadName= " +Thread.currentThread().getName()+" i= "+(i+1)); &#125; &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/13. */public class MyThread1 extends Thread&#123; private Task task; public MyThread1(Task task) &#123; super(); this.task=task; &#125; @Override public void run() &#123; super.run(); task.doLongTimeTask(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/13. */public class MyThread2 extends Thread&#123; private Task task; public MyThread2(Task task) &#123; super(); this.task=task; &#125; @Override public void run() &#123; super.run(); task.doLongTimeTask(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/13. */public class Run &#123; public static void main(String[] args) &#123; Task task=new Task(); MyThread1 thread1=new MyThread1(task); thread1.start(); MyThread2 thread2=new MyThread2(task); thread2.start(); &#125;&#125; 程序的结果不是固定的但从输出的结果来看是同步的：123456789101112131415161718192021222324252627nosynchronized threadName= Thread-0 i= 56nosynchronized threadName= Thread-1 i= 97nosynchronized threadName= Thread-0 i= 57nosynchronized threadName= Thread-1 i= 98nosynchronized threadName= Thread-0 i= 58nosynchronized threadName= Thread-1 i= 99nosynchronized threadName= Thread-0 i= 59nosynchronized threadName= Thread-1 i= 100nosynchronized threadName= Thread-0 i= 60nosynchronized threadName= Thread-0 i= 97synchronized threadName= Thread-1 i= 37nosynchronized threadName= Thread-0 i= 98synchronized threadName= Thread-1 i= 38nosynchronized threadName= Thread-0 i= 99synchronized threadName= Thread-1 i= 39nosynchronized threadName= Thread-0 i= 100synchronized threadName= Thread-1 i= 40synchronized threadName= Thread-1 i= 41synchronized threadName= Thread-1 i= 42synchronized threadName= Thread-1 i= 43synchronized threadName= Thread-1 i= 44synchronized threadName= Thread-1 i= 45synchronized threadName= Thread-1 i= 46synchronized threadName= Thread-1 i= 47synchronized threadName= Thread-1 i= 48 摘选自 java多线程核心编程技术-2.2.4]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.3用同步代码块解决同步方法的弊端]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F18%2Fsolve-drawbacks-of-synchronized%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * 线程任务 * 用同步代码块解决同步方法的弊端 * @author wuyoushan * @date 2017/1/23. */public class Task &#123; private String getData1; private String getData2; public void doLongTimeTask()&#123; try &#123; System.out.println("begin task"); Thread.sleep(3000); String privateGetData1="长时间处理任务后从远程返回的值1 threadName="+ Thread.currentThread().getName(); String privateGetData2="长时间处理任务后从远程返回的值2 threadName="+ Thread.currentThread().getName(); synchronized (this)&#123; getData1=privateGetData1; getData2=privateGetData2; &#125; System.out.println(getData1); System.out.println(getData2); System.out.println("end task"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/** * 常量定义 * 用同步代码块解决同步方法的弊端 * @author wuyoushan * @date 2017/1/23. */public class CommonUtils &#123; public static long beginTime1; public static long endTime1; public static long beginTime2; public static long endTime2;&#125;/**线程1 * 用同步代码块解决同步方法的弊端 * @author wuyoushan * @date 2017/1/23. */public class MyThread1 extends Thread &#123; private Task task; public MyThread1(Task task)&#123; this.task=task; &#125; @Override public void run() &#123; super.run(); CommonUtils.beginTime1=System.currentTimeMillis(); task.doLongTimeTask(); CommonUtils.endTime1=System.currentTimeMillis(); &#125;&#125;/** * 线程二 * synchronized方法的弊端 * @author wuyoushan * @date 2017/1/23. */public class MyThread2 extends Thread &#123; private Task task; public MyThread2(Task task)&#123; this.task=task; &#125; @Override public void run() &#123; super.run(); CommonUtils.beginTime2=System.currentTimeMillis(); task.doLongTimeTask(); CommonUtils.endTime2=System.currentTimeMillis(); &#125;&#125;/**运行实例 * 用同步代码块解决同步方法的弊端 * @author wuyoushan * @date 2017/1/23. */public class Run &#123; public static void main(String[] args) &#123; Task task=new Task(); MyThread1 thread1=new MyThread1(task); thread1.start(); MyThread2 thread2=new MyThread2(task); thread2.start(); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; long beginTime=CommonUtils.beginTime1; if (CommonUtils.beginTime2&lt;CommonUtils.beginTime1)&#123; beginTime=CommonUtils.beginTime2; &#125; long endTime=CommonUtils.endTime1; if (CommonUtils.endTime2&gt;CommonUtils.endTime1)&#123; endTime=CommonUtils.endTime2; &#125; System.out.println("耗时:"+((endTime-beginTime)/1000)); &#125;&#125; 程序的运行结果为：123456789begin taskbegin task长时间处理任务后从远程返回的值1 threadName=Thread-1长时间处理任务后从远程返回的值2 threadName=Thread-0end task长时间处理任务后从远程返回的值1 threadName=Thread-0长时间处理任务后从远程返回的值2 threadName=Thread-0end task耗时:3 通过上面的实验可以得知，当一个线程访问object的一个synchronized同步代码块时，另一个线程仍然可以访问改object对象中的非synchronized(this)同步代码块。 实验进行到这里，虽然时间缩短，运行效率加快，但同步synchronized代码块真的是同步的吗？真的持有当前调用对象的锁吗？答案为是，但必须用代码的方式来进行验证 摘选自 java多线程核心编程技术-2.2.3]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.2 synchronized同步代码块的使用]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F18%2Fsynchronized-code-block%2F</url>
    <content type="text"><![CDATA[当两个并发线程访问同一个对象object中的synchronized(this)同步代码块时，一段时间内只能有一个线程被执行，另一个线程必须等待当前线程执行完这个代码块以后以后才能执行该代码块。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * synchronized同步代码的使用 * @author wuyoushan * @date 2017/1/23. */public class ObjectService &#123; public void serviceMethod()&#123; try &#123; synchronized (this)&#123; System.out.println("begin Time="+System.currentTimeMillis()); Thread.sleep(2000); System.out.println("end end="+System.currentTimeMillis()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;/**ThreadA线程类 * synchronized同步代码的使用 * @author wuyoushan * @date 2017/1/23. */public class ThreadA extends Thread&#123; private ObjectService service; public ThreadA(ObjectService service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.serviceMethod(); &#125;&#125;/** * ThreadA线程类 * synchronized同步代码的使用 * @author wuyoushan * @date 2017/1/23. */public class ThreadB extends Thread&#123; private ObjectService service; public ThreadB(ObjectService service) &#123; this.service = service; &#125; @Override public void run() &#123; super.run(); service.serviceMethod(); &#125;&#125;/** * 运行实例 * synchronized同步代码的使用 * @author wuyoushan * @date 2017/1/23. */public class Run &#123; public static void main(String[] args) &#123; ObjectService service=new ObjectService(); ThreadA a=new ThreadA(service); a.setName("a"); a.start(); ThreadB b=new ThreadB(service); b.setName("b"); b.start(); &#125;&#125; 程序的运行结果为：1234begin Time=1492042714510end end=1492042716511begin Time=1492042716511end end=1492042718511 上面的实验虽然使用了synchronized同步代码块，但执行的效率还是没有提高，执行的效果还是同步运行的。如何用synchronized同步代码解决程序执行效率低的问题呢？ 摘选自 java多线程核心编程技术-2.2.2]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2.1synchronized方法的弊端]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F18%2Fsynchronized-method-malpractice%2F</url>
    <content type="text"><![CDATA[用关键字synchronized声明方法在某些情况下时有弊端的，比如A线程调用同步方法执行一个长时间的任务，那么B线程则必须等待比较长的时间。在这样的情况下可以使用synchronized同步语句块来解决 synchronized方法的弊端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112/** * @author wuyoushan * @date 2017/3/14. */public class Task &#123; private String getData1; private String getData2; public synchronized void doLongTimeTask()&#123; try &#123; System.out.println("begin task"); Thread.sleep(3000); getData1="长时间处理任务后从远程返回的值1 threadName=" +Thread.currentThread().getName(); getData2="长时间处理任务后从远程返回的值2 threadName=" +Thread.currentThread().getName(); System.out.println(getData1); System.out.println(getData2); System.out.println("end task"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/12. */public class CommonUtils &#123; public static long beginTime1; public static long endTime1; public static long beginTime2; public static long endTime2;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Task task; public ThreadA(Task task)&#123; super(); this.task=task; &#125; @Override public void run() &#123; super.run(); CommonUtils.beginTime1=System.currentTimeMillis(); task.doLongTimeTask(); CommonUtils.endTime1=System.currentTimeMillis(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private Task task; public ThreadB(Task task)&#123; super(); this.task=task; &#125; @Override public void run() &#123; super.run(); CommonUtils.beginTime2=System.currentTimeMillis(); task.doLongTimeTask(); CommonUtils.endTime2=System.currentTimeMillis(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; Task task=new Task(); ThreadA thread1=new ThreadA(task); thread1.start(); ThreadB thread2=new ThreadB(task); thread1.start(); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; long beginTime=CommonUtils.beginTime1; if(CommonUtils.beginTime2&lt;CommonUtils.beginTime1)&#123; beginTime=CommonUtils.beginTime2; &#125; long endTime=CommonUtils.endTime1; if (CommonUtils.endTime2&gt;CommonUtils.endTime1)&#123; endTime=CommonUtils.endTime2; &#125; System.out.println("耗时:"+(endTime-beginTime)/1000); &#125;&#125; 程序的运行结果为:123456789begin task长时间处理任务后从远程返回的值1 threadName=Thread-0长时间处理任务后从远程返回的值2 threadName=Thread-0end taskbegin task长时间处理任务后从远程返回的值1 threadName=Thread-1长时间处理任务后从远程返回的值2 threadName=Thread-1end task耗时：6 在使用synchronized关键字来声明方法public synchronized void doLongTimeTask()时从运行的时间上来看，弊端很明显(排序执行，花时间较长)，解决这样的问题可以使用synchronized同步块 摘选自 java多线程核心编程技术-2.2.1]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.8同步不具体有继承性]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F15%2Fsynchronized-no-inherit%2F</url>
    <content type="text"><![CDATA[同步不可以继承123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * @author wuyoushan * @date 2017/4/11. */public class Main &#123; synchronized public void serviceMethod()&#123; try &#123; System.out.println("int main 下一步sleep begin threadName="+ Thread.currentThread().getName()+" time="+ System.currentTimeMillis()); Thread.sleep(5000); System.out.println("int main 下一步sleep end threadName="+ Thread.currentThread().getName()+" time="+ System.currentTimeMillis()); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/11. */public class Sub extends Main &#123; @Override public void serviceMethod() &#123; try &#123; System.out.println("int sub 下一步sleep begin threadName="+ Thread.currentThread().getName()+" time="+ System.currentTimeMillis()); Thread.sleep(5000); System.out.println("int sub 下一步sleep end threadName="+ Thread.currentThread().getName()+" time="+ System.currentTimeMillis()); super.serviceMethod(); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Sub sub; public ThreadA(Sub sub)&#123; super(); this.sub=sub; &#125; @Override public void run() &#123; super.run(); sub.serviceMethod(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private Sub sub; public ThreadB(Sub sub)&#123; super(); this.sub=sub; &#125; @Override public void run() &#123; super.run(); sub.serviceMethod(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/14. */public class Test &#123; public static void main(String[] args) &#123; Sub subRef=new Sub(); ThreadA a=new ThreadA(subRef); a.setName("A"); a.start(); ThreadB b=new ThreadB(subRef); b.setName("B"); b.start(); &#125;&#125; 程序的结果:12345678int sub 下一步sleep begin threadName=A time=1491871403168int sub 下一步sleep begin threadName=B time=1491871403169int sub 下一步sleep end threadName=A time=1491871408169int main 下一步sleep begin threadName=A time=1491871408169int sub 下一步sleep end threadName=B time=1491871408170int main 下一步sleep end threadName=A time=1491871413169int main 下一步sleep begin threadName=B time=1491871413169int main 下一步sleep end threadName=B time=1491871418169 从上面第一行，第二行可以看到:运行结果是不同步的。由此可知，同步是不能继承，所以还得在子类的方法中添加synchronized关键字，添加以后的运行效果。12345678int sub 下一步sleep begin threadName=A time=1491872987559int sub 下一步sleep end threadName=A time=1491872992559int main 下一步sleep begin threadName=A time=1491872992559int main 下一步sleep end threadName=A time=1491872997560int sub 下一步sleep begin threadName=B time=1491872997560int sub 下一步sleep end threadName=B time=1491873002560int main 下一步sleep begin threadName=B time=1491873002560int main 下一步sleep end threadName=B time=1491873007560 摘选自 java多线程核心编程技术-2.1.8]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.7出现异常，锁自动释放]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F15%2Fexception-lock-freed%2F</url>
    <content type="text"><![CDATA[当一个线程值执行的代码出现异常时，其所持有的锁会自动释放123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; synchronized public void testMethod()&#123; if(Thread.currentThread().getName().equals("a"))&#123; System.out.println("ThreadName="+Thread.currentThread().getName()+ " run beginTime="+System.currentTimeMillis()); int i=1; while(i==1)&#123; if((""+Math.random()).substring(0,8).equals("0.123456"))&#123; System.out.println("ThreadName=" +Thread.currentThread().getName() +" run exceptionTime=" +System.currentTimeMillis()); Integer.parseInt("a"); &#125; &#125; &#125;else&#123; System.out.println("Thread B run Time="+System.currentTimeMillis()); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private Service service; public ThreadA(Service service)&#123; super(); this.service=service; &#125; @Override public void run() &#123; super.run(); service.testMethod(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private Service service; public ThreadB(Service service)&#123; super(); this.service=service; &#125; @Override public void run() &#123; super.run(); service.testMethod(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/14. */public class Test &#123; public static void main(String[] args) &#123; try&#123; Service service=new Service(); ThreadA a=new ThreadA(service); a.setName("a"); a.start(); a.sleep(200); Thread.sleep(500); ThreadB b=new ThreadB(service); b.setName("b"); b.start(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:123456789ThreadName=a run beginTime=1491870317217ThreadName=a run exceptionTime=1491870317336Exception in thread "a" java.lang.NumberFormatException: For input string: "a" at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.lang.Integer.parseInt(Integer.java:492) at java.lang.Integer.parseInt(Integer.java:527) at wys.test.Service.testMethod(Service.java:20) at wys.test.ThreadA.run(ThreadA.java:19)Thread B run Time=1491870317918 线程a出现异常并释放锁，线程b进入方法正常打印，实验的结论就是出现异常的锁被自动释放了。 摘选自 java多线程核心编程技术-2.1.7]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.6synchronized锁重入]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F15%2Fsynchronized-lock-reentry%2F</url>
    <content type="text"><![CDATA[关键字synchronized拥有锁重入的功能，也就是在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时是可以再次得到该对象锁的。这也证明在一个synchronized方法/块的内部调用本类的其他synchronized方法/块时，是永远可以得到锁的。123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @author wuyoushan * @date 2017/4/10. */public class Service &#123; synchronized public void service1()&#123; System.out.println("service1"); service2(); &#125; synchronized public void service2() &#123; System.out.println("service2"); service3(); &#125; synchronized public void service3() &#123; System.out.println("service3"); &#125;&#125;/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; @Override public void run() &#123; Service service=new Service(); service.service1(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; MyThread thread=new MyThread(); thread.start(); &#125;&#125; 程序的运行结果:123service1service2service3 “可重入锁”的概念是:自己可以再次获取自己的内部锁。比如有1条线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。 可重入锁也支持在父子类继承的环境中1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @author wuyoushan * @date 2017/4/11. */public class Main &#123; public int i=10; synchronized public void operateMainMethod()&#123; try &#123; i--; System.out.println("main print i=" + i); Thread.sleep(100); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/11. */public class Sub extends Main &#123; synchronized public void operateISubMethod()&#123; try&#123; while (i&gt;0) &#123; i--; System.out.println("sub print i="+i); Thread.sleep(100); this.operateMainMethod(); &#125; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; @Override public void run() &#123; Sub sub=new Sub(); sub.operateISubMethod(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; MyThread thread=new MyThread(); thread.start(); &#125;&#125; 程序运行结果为:12345678910sub print i=9main print i=8sub print i=7main print i=6sub print i=5main print i=4sub print i=3main print i=2sub print i=1main print i=0 此程序说明，当存在父类继承关系时，子类是完全可以通过“可重入锁”调用父类的同步方法的。 摘选自 java多线程核心编程技术-2.1.6]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.5脏读]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F15%2Fdirty-read%2F</url>
    <content type="text"><![CDATA[实现多个线程调用同一个方法时，为避免数据出现交叉的情况，使用synchronized关键字进行同步 虽然在赋值时进行了同步，但在取值时有可能出现一些意想不到的意外，这种情况就是脏读。发生脏读的情况是在读取实例变量时，此值已经被其他线程更改过了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * @author wuyoushan * @date 2017/4/10. */public class PublicVar &#123; public String username="A"; public String password="AA"; synchronized public void setValue(String username,String password)&#123; try&#123; this.username=username; Thread.sleep(5000); this.password=password; System.out.println("setValue method thread name="+ Thread.currentThread().getName()+" username="+ username+" password="+password); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; public void getValue()&#123; System.out.println("getValue method thread name="+ Thread.currentThread().getName()+" username="+ username+" password="+password); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private PublicVar publicVar; public ThreadA(PublicVar publicVar)&#123; super(); this.publicVar=publicVar; &#125; @Override public void run() &#123; super.run(); publicVar.setValue("B","BB"); &#125;&#125;/** * @author wuyoushan * @date 2017/3/14. */public class Test &#123; public static void main(String[] args) &#123; try&#123; PublicVar publicVar=new PublicVar(); ThreadA thread=new ThreadA(publicVar); thread.start(); Thread.sleep(200); publicVar.getValue(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为：12getValue method thread name=main username=B password=AAsetValue method thread name=Thread-0 username=B password=BB 出现脏读是因为public void getValue()方法并不是同步的，所以可以在任意时候进行调用。解决方法当然就是加上同步synchronized关键字，代码如下:123456789101112131415161718192021222324252627/** * @author wuyoushan * @date 2017/4/10. */public class PublicVar &#123; public String username="A"; public String password="AA"; synchronized public void setValue(String username,String password)&#123; try&#123; this.username=username; Thread.sleep(5000); this.password=password; System.out.println("setValue method thread name="+ Thread.currentThread().getName()+" username="+ username+" password="+password); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; synchronized public void getValue()&#123; System.out.println("getValue method thread name="+ Thread.currentThread().getName()+" username="+ username+" password="+password); &#125;&#125; 程序的运行结果为:12setValue method thread name=Thread-0 username=B password=BBgetValue method thread name=main username=B password=BB 可见，方法setValue()和getValue()被依次执行。通过这个案例不仅要知道脏读是通过synchronized关键字解决的，还要知道如下内容: 当A线程调用anyObject对象加入synchronized关键字的X方法时，A线程就获得了X方法的锁，更准确的讲，是获取了对象的锁，所以其他线程必须等A线程执行完毕才可以调用X方法，但B线程可以随意调用其他的非synchronized同步方法 当A线程调用anyObject对象加入synchronized关键字的X方法时，A线程就获得了X方法的所在对象的锁，所以其他线程必须等A线程执行完毕才可以调用X方法，而B线程如果调用声明了synchronized关键字的非X方法时，必须等A线程将X方法执行完，也就是释放对象锁后才可以调用。这时A线程已经执行了一个完整的任务，也就是说username和password这两个实例变量已经同时被赋值，不存在脏读的基本环境 摘选自 java多线程核心编程技术-2.1.5]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.4synchronized方法与对象锁]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F15%2Fsynchronized-method-and-object-lock%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * @author wuyoushan * @date 2017/3/29. */public class MyObject &#123; public void methodA()&#123; try &#123; System.out.println("begin methodA threadName=" + Thread.currentThread().getName()); Thread.sleep(1000); System.out.println("end"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private MyObject object; public ThreadA(MyObject object)&#123; super(); this.object=object; &#125; @Override public void run() &#123; super.run(); object.methodA(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private MyObject object; public ThreadB(MyObject object)&#123; super(); this.object=object; &#125; @Override public void run() &#123; super.run(); object.methodA(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; MyObject object=new MyObject(); ThreadA threadA=new ThreadA(object); threadA.setName("A"); ThreadB threadB=new ThreadB(object); threadB.setName("B"); threadA.start(); threadB.start(); &#125;&#125; 程序运行候的结果为:1234begin methodA threadName=Abegin methodA threadName=Bendend 更改MyObject.java中的代码:12345678910111213141516/** * @author wuyoushan * @date 2017/3/29. */public class MyObject &#123; synchronized public void methodA()&#123; try &#123; System.out.println("begin methodA threadName=" + Thread.currentThread().getName()); Thread.sleep(1000); System.out.println("end"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 更改后得运行结果为：1234begin methodA threadName=Aendbegin methodA threadName=Bend 通过上面的实验结论，调用关键字synchronized声明的方法一定是排队运行的。另外需要牢牢记住“共享”这两个字，只有共享资源的读写访问才需要同步化，如果不是共享资源，那么根本就没有同步的必要。 那其他的方法被调用时会是什么效果呢？如何查看到Lock锁对象效果呢？12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * @author wuyoushan * @date 2017/3/29. */public class MyObject &#123; synchronized public void methodA()&#123; try &#123; System.out.println("begin methodA threadName=" + Thread.currentThread().getName()); Thread.sleep(1000); System.out.println("end endTime="+System.currentTimeMillis()); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; public void methodB()&#123; try &#123; System.out.println("begin methodB threadName=" + Thread.currentThread().getName()+"begin time"+ System.currentTimeMillis()); Thread.sleep(1000); System.out.println("end"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private MyObject object; public ThreadA(MyObject object)&#123; super(); this.object=object; &#125; @Override public void run() &#123; super.run(); object.methodA(); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private MyObject object; public ThreadB(MyObject object)&#123; super(); this.object=object; &#125; @Override public void run() &#123; super.run(); object.methodB(); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; MyObject object=new MyObject(); ThreadA threadA=new ThreadA(object); threadA.setName("A"); ThreadB threadB=new ThreadB(object); threadB.setName("B"); threadA.start(); threadB.start(); &#125;&#125; 程序的运行结果为:1234begin methodA threadName=Abegin methodB threadName=Bbegin time1491525491404endend endTime=1491525492404 通过上面的实验可以得知，虽然线程A先持有了object对象的锁，但线程B完全可以异步调用非synchronized类型的方法。 如果将MyObject.java文件中的methodB()方法前加上synchronized关键字，代码如下：12345678910111213141516171819202122232425262728/** * @author wuyoushan * @date 2017/3/29. */public class MyObject &#123; synchronized public void methodA()&#123; try &#123; System.out.println("begin methodA threadName=" + Thread.currentThread().getName()); Thread.sleep(1000); System.out.println("end endTime="+System.currentTimeMillis()); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; synchronized public void methodB()&#123; try &#123; System.out.println("begin methodB threadName=" + Thread.currentThread().getName()+"begin time"+ System.currentTimeMillis()); Thread.sleep(1000); System.out.println("end"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果为:1234begin methodA threadName=Aend endTime=1491525875727begin methodB threadName=Bbegin time1491525875727end 此实验的结论是: A线程先持有object对象的Lock锁，B线程可以以异步的方式调用object对象中的非synchronized类型的方法。 A线程先持有object对象的Lock锁，B线程如果在这时调用object对象中的synchronized类型的方法则需等待，也就是同步。 摘选自 java多线程核心编程技术-2.1.4]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.3多个对象多个锁]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F15%2Fmuch-object-much-lock%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * @author wuyoushan * @date 2017/4/4. */public class HasSelfPrivateNum &#123; private int num=0; synchronized public void addI(String username)&#123; try &#123; if (username.equals("a")) &#123; num = 100; System.out.println("a set over!"); Thread.sleep(200); &#125;else&#123; num=200; System.out.println("b set over!"); &#125; System.out.println(username+" num="+num); &#125;catch (Exception ex)&#123; ex.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private HasSelfPrivateNum numRef; public ThreadA(HasSelfPrivateNum numRef)&#123; super(); this.numRef=numRef; &#125; @Override public void run() &#123; super.run(); numRef.addI("a"); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private HasSelfPrivateNum numRef; public ThreadB(HasSelfPrivateNum numRef)&#123; super(); this.numRef=numRef; &#125; @Override public void run() &#123; super.run(); numRef.addI("b"); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; HasSelfPrivateNum numRef1=new HasSelfPrivateNum(); HasSelfPrivateNum numRef2=new HasSelfPrivateNum(); ThreadA threadA=new ThreadA(numRef1); threadA.start(); ThreadB threadB=new ThreadB(numRef2); threadB.start(); &#125;&#125; 程序的运行结果如下:1234a set over!b set over!b num=200a num=100 上面的示例是两个线程分别访问同一个类的两个不同实例的相同名称的同步方法，效果却是以异步的方式运行的。本示例由于创建了2个业务对象，在系统中产生出2个锁，所以运行结果是异步的，打印的效果就是先打印b,然后打印a。 从上面程序运行结果来看，虽然在HasSelfPrivateNum.java中使用了synchronized关键字，但打印的顺序却不是同步的，是交叉的。为什么是这样的结果呢？ 关键字synchronized取得的锁都是对象锁，而不是把一段代码或方法（函数）当作锁，所以在上面的示例中，哪个线程先执行带synchronized关键字的方法，哪个线程就持有该方法所属对象的锁Lock,那么其他线程只能呈等待状态，前提是多个线程访问的是同一个对象。 摘选自 java多线程核心编程技术-2.1.3]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.2实例变量非线程安全]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F15%2Fvar-non-thread-safe%2F</url>
    <content type="text"><![CDATA[2.1.2实例变量非线程安全如果多个线程共同访问1个对象中的实例变量，则有可能出现“非线程安全”问题。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980/** * @author wuyoushan * @date 2017/4/4. */public class HasSelfPrivateNum &#123; private int num=0; public void addI(String username)&#123; try &#123; if (username.equals("a")) &#123; num = 100; System.out.println("a set over!"); Thread.sleep(200); &#125;else&#123; num=200; System.out.println("b set over!"); &#125; System.out.println(username+" num="+num); &#125;catch (Exception ex)&#123; ex.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private HasSelfPrivateNum numRef; public ThreadA(HasSelfPrivateNum numRef)&#123; super(); this.numRef=numRef; &#125; @Override public void run() &#123; super.run(); numRef.addI("a"); &#125;&#125;/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private HasSelfPrivateNum numRef; public ThreadB(HasSelfPrivateNum numRef)&#123; super(); this.numRef=numRef; &#125; @Override public void run() &#123; super.run(); numRef.addI("b"); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; HasSelfPrivateNum numRef=new HasSelfPrivateNum(); ThreadA threadA=new ThreadA(numRef); threadA.start(); ThreadB threadB=new ThreadB(numRef); threadB.start(); &#125;&#125; 程序运行结果为:1234a set over!b set over!b num=200a num=200 本实验是两个线程同时访问一个没有同步的方法，如果两个线程同时操作业务对象中的实例变量，则有可能会出现“非线程安全”问题。修改HasSelfPrivateNum.java文件如下123456789101112131415161718192021222324/** * @author wuyoushan * @date 2017/4/4. */public class HasSelfPrivateNum &#123; private int num=0; synchronized public void addI(String username)&#123; try &#123; if (username.equals("a")) &#123; num = 100; System.out.println("a set over!"); Thread.sleep(200); &#125;else&#123; num=200; System.out.println("b set over!"); &#125; System.out.println(username+" num="+num); &#125;catch (Exception ex)&#123; ex.printStackTrace(); &#125; &#125;&#125; 重新运行程序，运行结果为:1234a set over!a num=100b set over!b num=200 摘选自 java多线程核心编程技术-2.1.2]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1synchronized同步方法]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F15%2Fsynchronized-method%2F</url>
    <content type="text"><![CDATA[“线程安全”与“非线程安全”相关的技术点，它们是学习多线程技术时一定会遇到的经典问题。“非线程安全”其实会在多个线程对同一个对象中的实例变量进行并发访问是发生时发生，产生的后果就是“脏读”，也就是取到的数据其实是被更改过的。，而”线程安全”就是以获得的实例变量的值是经过同步处理的，不会出现脏读的现象。 2.1.1方法内的变量“非线程安全”问题存在于“实例变量”中，如果是方法内部的私有变量则不存在“非线程安全”问题，所得结果也就是“线程安全”的了。12345678910111213141516171819202122/** * @author wuyoushan * @date 2017/4/4. */public class HasSelfPrivateNum &#123; public void addI(String username)&#123; try &#123; int num = 0; if (username.equals("a")) &#123; num = 100; System.out.println("a set over!"); Thread.sleep(200); &#125;else&#123; num=200; System.out.println("b set over!"); &#125; System.out.println(username+" num="+num); &#125;catch (Exception ex)&#123; ex.printStackTrace(); &#125; &#125;&#125; 文件ThreadA.java代码如下：12345678910111213141516171819/** * @author wuyoushan * @date 2017/4/4. */public class ThreadA extends Thread&#123; private HasSelfPrivateNum numRef; public ThreadA(HasSelfPrivateNum numRef)&#123; super(); this.numRef=numRef; &#125; @Override public void run() &#123; super.run(); numRef.addI("a"); &#125;&#125; 文件ThreadB.java代码如下:12345678910111213141516171819202122232425262728293031323334/** * @author wuyoushan * @date 2017/4/4. */public class ThreadB extends Thread&#123; private HasSelfPrivateNum numRef; public ThreadB(HasSelfPrivateNum numRef)&#123; super(); this.numRef=numRef; &#125; @Override public void run() &#123; super.run(); numRef.addI("b"); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; HasSelfPrivateNum numRef=new HasSelfPrivateNum(); ThreadA threadA=new ThreadA(numRef); threadA.start(); ThreadB threadB=new ThreadB(numRef); threadB.start(); &#125;&#125; 运行结果如下:1234a set over!b set over!b num=200a num=100 摘选自 java多线程核心编程技术-2.1]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.11守护线程]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F13%2Fdaemon-thread%2F</url>
    <content type="text"><![CDATA[在java线程中有两种线程，一种是用户线程，另一种是守护线程。守护线程是一种特殊的线程，它的特殊有“陪伴”的含义，当进程中不存在非守护线程了，则守护线程自动销毁。典型的守护线程就是垃圾回收线程，当进程中没有非守护进程了，则垃圾回收线程也就没有存在的必要了，自动销毁。用一个比较通俗的比喻来解释一下“守护线程”：任何一个守护线程都是整个JVM中所有非守护线程的“保姆”，只要当前JVM实例中存在任何一个非守护线程没有结束，守护线程就在工作，只有当最后一个非守护线程结束时，守护线程才随着JVM一同结束工作。Daemon的作用就是为其他线程的运行提供便利服务，守护线程最经典的应用就是GC(垃圾回收器)，它是一个很称职 的守护者。12345678910111213141516171819202122232425262728293031323334353637383940/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; private int i=0; @Override public void run() &#123; try&#123; while(true)&#123; i++; System.out.println("i="+(i)); Thread.sleep(1000); &#125; &#125;catch(InterruptedException ex)&#123; ex.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; try &#123; MyThread thread = new MyThread(); thread.setDaemon(true); thread.start(); Thread.sleep(5000); System.out.println("我离开thread对象也不再打印了，也就是停止了！"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果如下:1234567i=1i=2i=3i=4i=5i=6我离开thread对象也不再打印了，也就是停止了！ 摘选自 java多线程核心编程技术-1.11]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.9yield方法]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F13%2Fyield-method%2F</url>
    <content type="text"><![CDATA[yield方法的作用是放弃当前的CPU资源，将它让给其他的任务去占用CPU执行时间。但放弃的时间不确定，也有可能刚刚放弃，马上又获得CPU时间片。123456789101112131415161718192021222324252627282930/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; @Override public void run() &#123; long beginTime=System.currentTimeMillis(); int count=0; for (int i=0;i&lt;50000000;i++)&#123; //Thread.yield(); count=count+(i+1); &#125; long endTime=System.currentTimeMillis(); System.out.println("用时:"+(endTime-beginTime)+"毫秒！"); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) throws InterruptedException &#123; MyThread myThread=new MyThread(); myThread.start(); &#125;&#125; 程序的运行结果为:1用时:33毫秒！ 将代码：1//Thread.yield(); 去掉注释符号，再次运行，运行结果如下:1用时:10546毫秒！ 运行变慢的原因是。yield()方法将CPU让给其他资源导致速度的变慢。 摘选自 java多线程核心编程技术-1.9]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.8.3suspend与resume方法的缺点——不同步]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F13%2Fsuspend-and-resume-defect-not-synchronized%2F</url>
    <content type="text"><![CDATA[在使用suspend与resume方法时也容易出现因为线程的暂停而导致数据不同步的情况。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * @author wuyoushan * @date 2017/3/29. */public class MyObject &#123; private String userName="1"; private String password="11"; public void setValue(String u,String p)&#123; this.userName=u; if(Thread.currentThread().getName().equals("a"))&#123; System.out.println("停止a线程!"); Thread.currentThread().suspend(); &#125; this.password=p; &#125; public void printUserNamePassword()&#123; System.out.println(userName+" "+password); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) throws InterruptedException &#123; final MyObject myObject=new MyObject(); Thread thread1=new Thread()&#123; @Override public void run() &#123; super.run(); myObject.setValue("a","aa"); &#125; &#125;; thread1.setName("a"); thread1.start(); Thread.sleep(500); Thread thread2=new Thread()&#123; @Override public void run() &#123; super.run(); myObject.printUserNamePassword(); &#125; &#125;; thread2.start(); &#125;&#125; 运行结果如下:12停止a线程!a 11 摘选自 java多线程核心编程技术-1.8.3]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.8.2suspend与resume方法的缺点——独占]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F13%2Fsuspend-and-resume-defect%2F</url>
    <content type="text"><![CDATA[在使用suspend与resume方法时，如果使用不当，极易造成公共的同步对象的独占，使得其他线程无法访问公共同步对象。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * @author wuyoushan * @date 2017/3/27. */public class SynchronizedObject &#123; synchronized public void printString()&#123; System.out.println("begin"); if(Thread.currentThread().getName().equals("a"))&#123; System.out.println("a线程永远suspend了！"); Thread.currentThread().suspend(); &#125; System.out.println("end"); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; try &#123; final SynchronizedObject object = new SynchronizedObject(); Thread thread1 = new Thread() &#123; @Override public void run() &#123; object.printString(); &#125; &#125;; thread1.setName("a"); thread1.start(); Thread.sleep(1000); Thread thread2=new Thread()&#123; @Override public void run() &#123; System.out.println("thread2启动了，但进入不了printString()方法！只打印1个begin"); System.out.println("因为printString()方法被a线程锁定并且永远suspend暂停了！"); object.printString(); &#125; &#125;; thread2.start(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果为：1234begina线程永远suspend了！thread2启动了，但进入不了printString()方法！只打印1个begin因为printString()方法被a线程锁定并且永远suspend暂停了！ 还有另外一种独占锁的情况也要格外的注意，稍有不慎，就会掉进“坑”里。1234567891011121314151617181920212223242526272829303132333435/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; private long i=0; @Override public void run() &#123; while (true)&#123; i++; &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; try &#123; MyThread thread = new MyThread(); thread.start(); Thread.sleep(1000); thread.suspend(); System.out.println("main end!"); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果为：1main end! 如果将线程类MyThread.java更改如下：1234567891011121314151617/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; private long i=0; @Override public void run() &#123; while (true)&#123; i++; System.out.println("i="+i); &#125; &#125;&#125; 再次运行程序，控制台将不打印main end，运行结果如下1234567i=98713i=98714i=98715i=98716i=98717i=98718i=98719 出现这样结果的原因是，当程序运行到println()方法内部停止时，同步锁未被释放。方法println()源代码如下:123456public void println(String x) &#123; synchronized (this) &#123; print(x); newLine(); &#125; &#125; 这导致当前PrintStream对象的println()方法一直呈“暂停”状态，并且“锁未释放”，而main()方法中的代码System.out.println(“main end!”);迟迟不能执行打印。虽然suspuend()方法是过期作废的方法，但还是有必要研究它过期作废的原因，这是很有意义的。 摘选自 java多线程核心编程技术-1.8.2]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.8暂停线程]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F13%2Fsuspend-thread%2F</url>
    <content type="text"><![CDATA[暂停线程意味着此线程还可以恢复运行。在java多线程中，还可以使用suspend()方法暂停线程，使用resume()方法恢复线程的执行。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; private long i=0; public Long getI() &#123; return i; &#125; public void setI(long i) &#123; this.i = i; &#125; @Override public void run() &#123; while (true)&#123; i++; &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; try&#123; MyThread thread=new MyThread(); thread.start(); Thread.sleep(5000); //A段 thread.suspend(); System.out.println("A="+System.currentTimeMillis()+"i="+thread.getI()); Thread.sleep(5000); System.out.println("A="+System.currentTimeMillis()+"i="+thread.getI()); //B段 thread.resume(); Thread.sleep(5000); //C段 thread.suspend(); System.out.println("B="+System.currentTimeMillis()+"i="+thread.getI()); Thread.sleep(5000); System.out.println("B="+System.currentTimeMillis()+"i="+thread.getI()); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 从控制台的打印结果来看，线程的确被暂停了，而且还可以恢复成运行状态。1234A=1490576230229i=2056518687A=1490576235229i=2056518687B=1490576240229i=4141381898B=1490576245229i=4141381898 摘选自 java多线程核心编程技术-1.8]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.7.8使用return停止线程]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F13%2Freturn-stop-thread%2F</url>
    <content type="text"><![CDATA[将方法interrupt()与return结合使用也能实现停止线程的效果。1234567891011121314151617181920212223242526272829303132333435/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; @Override public void run() &#123; while (true)&#123; if(this.isInterrupted())&#123; System.out.println("停止了！"); return; &#125; System.out.println("timer="+ System.currentTimeMillis()); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; try&#123; MyThread thread=new MyThread(); thread.start(); Thread.sleep(200); thread.interrupt(); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果为：12345678timer=1490575062355timer=1490575062355timer=1490575062355timer=1490575062355timer=1490575062355timer=1490575062355timer=1490575062355停止了！ 不过还是建议使用“抛异常”的方法来实现线程的停止，因为在catch块中还可以将异常向上抛，使线程停止的事件得以传播。 摘选自 java多线程核心编程技术-1.7.8]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.7.7释放锁的不良后果]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F13%2Frelease-lock-result%2F</url>
    <content type="text"><![CDATA[使用stop()释放锁将会给数据造成不一致的结果。如果出现这样的情况，程序处理的数据就有可能遭到破坏，最终导致程序执行的流程出错，一定要特别注意。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * @author wuyoushan * @date 2017/3/27. */public class SynchronizedObject &#123; private String username="a"; private String password="aa"; public void printString(String username,String password)&#123; try&#123; this.username=username; Thread.sleep(100000); this.password=password; &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125;/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; private SynchronizedObject object; public MyThread(SynchronizedObject object) &#123; this.object = object; &#125; @Override public void run() &#123; object.printString("b","bb"); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; try&#123; SynchronizedObject object=new SynchronizedObject(); MyThread thread=new MyThread(object); thread.start(); Thread.sleep(500); thread.stop(); System.out.println(object.getUsername()+" "+object.getPassword()); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 程序的运行结果如下：1b aa 由于stop()方法已经在JDK中被标明是“作废/过期”的方法，显然它在功能上具有缺陷，所以不建议在程序中使用stop()方法 摘选自 java多线程核心编程技术-1.7.7]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.7.6方法stop()与java.lang.ThreadDeath异常]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F13%2Fstop-and-thread-death%2F</url>
    <content type="text"><![CDATA[调用stop()方法时会抛出java.lang.ThreadDeath异常，但在通常的情况下，此异常不需要显式地捕捉。12345678910111213141516171819202122232425262728/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; private int i=0; @Override public void run() &#123; try &#123; this.stop(); &#125;catch(ThreadDeath e)&#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; MyThread myThread=new MyThread(); myThread.start(); &#125;&#125; 运行结果为：12345java.lang.ThreadDeath at java.lang.Thread.stop(Thread.java:836) at wys.test.MyThread.run(MyThread.java:14)Process finished with exit code 0 方法stop()已经被作废，因为如果强制让线程停止则有可能使一些清理性的工作得不到完成。另外一个情况就是对锁定的对象进行了“解锁”，导致数据得不到同步的处理，出现数据不一致的问题。 摘选自 java多线程核心编程技术-1.7.6]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.7.5能停止的线程——暴力停止]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F13%2Fthread-stop-force%2F</url>
    <content type="text"><![CDATA[使用stop()方法停止线程则是非常暴力的。123456789101112131415161718192021222324252627282930313233343536373839/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; private int i=0; @Override public void run() &#123; super.run(); try &#123; while(true)&#123; i++; System.out.println("i="+i); Thread.sleep(1000); &#125; &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args)&#123; try &#123; MyThread myThread=new MyThread(); myThread.start(); Thread.sleep(8000); myThread.stop(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果为：12345678910i=1i=2i=3i=4i=5i=6i=7i=8Process finished with exit code 0 摘选自 java多线程核心编程技术-1.7.5]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.7.4在沉睡中停止]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F13%2Fthread-stop-in-sleep%2F</url>
    <content type="text"><![CDATA[如果线程在sleep()状态下停止线程，会是什么效果呢？123456789101112131415161718192021222324252627282930313233343536373839/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); try &#123; System.out.println("run begin"); Thread.sleep(200000); System.out.println("run end"); &#125;catch(InterruptedException e)&#123; System.out.println("在沉睡中被停止！进入catch！"+this.isInterrupted()); e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) &#123; try &#123; MyThread myThread=new MyThread(); myThread.start(); Thread.sleep(200); myThread.interrupt(); &#125; catch (InterruptedException e) &#123; System.out.println("main catch"); e.printStackTrace(); &#125; System.out.println("end"); &#125;&#125; 程序的运行结果如下：123456run beginjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at wys.test.MyThread.run(MyThread.java:15)end在沉睡中被停止！进入catch！false 从输出的结果来看，如果在sleep状态下停止某一线程，会进入catch语句中，并清除停止状态值，使之变成false 前一个实验是先sleep然后再用interrupt()停止，与之相反的操作在学习线程时也要注意。123456789101112131415161718192021222324252627282930313233343536/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); try &#123; for (int i=0;i&lt;100000;i++)&#123; System.out.println("i="+(i+1)); &#125; System.out.println("run begin"); Thread.sleep(200000); System.out.println("run end"); &#125;catch(InterruptedException e)&#123; System.out.println("先停止，再遇到了sleep！进入catch！"); e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) &#123; MyThread myThread=new MyThread(); myThread.start(); myThread.interrupt(); System.out.println("end!"); &#125;&#125; 运行结果如下:12345678910i=99996i=99997i=99998i=99999i=100000run begin先停止，再遇到了sleep！进入catch！java.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at wys.test.MyThread.run(MyThread.java:18) 摘选自 java多线程核心编程技术-1.7.4]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.7.3能停止的线程——异常法]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F13%2Fthread-stop-exception%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); for (int i=0;i&lt;500000;i++)&#123; if(this.interrupted())&#123; System.out.println("已经是停止状态了！我要退出了！"); break; &#125; System.out.println("i="+(i+1)); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) &#123; try &#123; MyThread myThread=new MyThread(); myThread.start(); Thread.sleep(2000); myThread.interrupt(); &#125; catch (InterruptedException e) &#123; System.out.println("main catch"); e.printStackTrace(); &#125; System.out.println("end"); &#125;&#125; 程序运行结果：12345678i=274421i=274422i=274423i=274424i=274425i=274426已经是停止状态了！我要退出了！end 上面的示例虽然停止了线程，但如果for语句下面还有语句，还是会继续运行的。示例如下：123456789101112131415161718192021222324252627282930313233343536373839/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); for (int i=0;i&lt;500000;i++)&#123; if(this.interrupted())&#123; System.out.println("已经是停止状态了！我要退出了！"); break; &#125; System.out.println("i="+(i+1)); &#125; System.out.println("我被输出，如果此代码是for又继续运行，线程并未停止！"); &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) &#123; try &#123; MyThread myThread=new MyThread(); myThread.start(); Thread.sleep(2000); myThread.interrupt(); &#125; catch (InterruptedException e) &#123; System.out.println("main catch"); e.printStackTrace(); &#125; System.out.println("end"); &#125;&#125; 运行结果如下:123456789i=308968i=308969i=308970i=308971i=308972i=308973已经是停止状态了！我要退出了！我被输出，如果此代码是for又继续运行，线程并未停止！end 那该如何解决语句继续运行的问题呢？看一下更新后的代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); try &#123; for (int i = 0; i &lt; 500000; i++) &#123; if (this.interrupted()) &#123; System.out.println("已经是停止状态了！我要退出了！"); //抛出线程中断异常 throw new InterruptedException(); &#125; System.out.println("i=" + (i + 1)); &#125; System.out.println("我在for下面"); &#125;catch(InterruptedException e)&#123; System.out.println("进入MyThread.java类run方法中的catch了！"); e.printStackTrace(); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) &#123; try &#123; MyThread myThread=new MyThread(); myThread.start(); Thread.sleep(2000); myThread.interrupt(); &#125; catch (InterruptedException e) &#123; System.out.println("main catch"); e.printStackTrace(); &#125; System.out.println("end"); &#125;&#125; 运行结果如下:123456789101112i=162100i=162101i=162102i=162103i=162104i=162105i=162106已经是停止状态了！我要退出了！进入MyThread.java类run方法中的catch了！endjava.lang.InterruptedException at wys.test.MyThread.run(MyThread.java:18) 摘选自 java多线程核心编程技术-1.7.3]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.7.2判断线程是否是停止的状态]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F09%2Fthread-whether-stop%2F</url>
    <content type="text"><![CDATA[在java的SDK中，Thread.java类里提供了两种方法。 this.interrupted():测试当前线程是否已中断。 this.isInterrupted():测试线程是否已经中断。123456789101112131415/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); for (int i=0;i&lt;500000;i++)&#123; System.out.println("i="+(i+1)); &#125; &#125;&#125; 123456789101112131415161718192021/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) &#123; try &#123; MyThread myThread=new MyThread(); myThread.start(); Thread.sleep(1000); //中断线程 myThread.interrupt(); System.out.println("是否停止1？="+myThread.interrupted()); System.out.println("是否停止2？="+myThread.interrupted()); &#125; catch (InterruptedException e) &#123; System.out.println("main catch"); e.printStackTrace(); &#125; System.out.println("end"); &#125;&#125; 控制台打印的结果:123是否停止1？=false是否停止2？=falseend 从控制台打印的结果来看，线程并未停止，这也就证明了interrupted()方法的解释:测试当前线程是否已经中断。这个“当前线程”是main，它从未中断过，所以打印的结果是两个false 123456789101112/** * @author wuyoushan * @date 2017/3/20. */public class Run2 &#123; public static void main(String[] args) &#123; Thread.currentThread().interrupt(); System.out.println("是否停止1？="+Thread.interrupted()); System.out.println("是否停止2？="+Thread.interrupted()); System.out.println("end"); &#125;&#125; 控制台打印出来的结果:123是否停止1？=true是否停止2？=falseend 从上述的结果来看，方法interrupted()的确判断出当前线程是否是停止状态。但为什么第二个布尔值是false呢？查看一下官方帮助文档中对interrupted方法的解释: 测试当前线程是否已经中断。线程的中断状态由该方法清除。换句话说，如果连续两次调用该方法，则第二次调用将返回false（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外） 文档已经解析得很详细，interrupted()方法具有清除状态的功能，所以第2次调用interrupted()方法返回的值是false interrupted():测试当前线程是否已经是中断状态，执行后具有将状态标志置清除为false的功能。 isInterrupted()：测试线程Thread对象是否已经是中断状态，但不清除中断状态标志。 摘选自 java多线程核心编程技术-1.7.2]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.7.1停不了的线程]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F09%2Fnot-stop-thread%2F</url>
    <content type="text"><![CDATA[停止一个线程意味着在线程处理完任务之前停掉正在做的操作，也就是放弃当前的操作。虽然这看起来非常简单，但是必须做好防范措施，以便达到预期的效果。停止一个线程可以用Thread.stop()方法，但最好不用它。虽然它确实可以停止一个正在运行的线程，但是这个方法是不安全的(unsafe),而且是已被弃用作废的(deprecated),在将来的java版本中，这个方法将不可用或不被支持。 大多数停止一个线程的操作使用Thread.interrupt()方法,尽管方法的名称是“停止，中止”的意思，但这个方法不会终止一个正在运行的线程，还需要加入一个判断才可以完成线程的停止。 在java中有以下3种方法可以终止正在运行的线程: 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。 使用stop()方法强行终止线程，但是不推荐使用这个方法，因为stop和suspend及resume一样，都是作废过期的方法，使用它们可能产生不可预料的结果 使用interrupt方法中断线程。 停不了的线程123456789101112131415161718192021222324252627282930313233/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; @Override public void run() &#123; super.run(); for (int i=0;i&lt;500000;i++)&#123; System.out.println("i="+(i+1)); &#125; &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) &#123; MyThread myThread=new MyThread(); myThread.start(); try &#123; Thread.sleep(2000); //中断线程 myThread.interrupt(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 从程序的运行结果来看，调用interrupt方法并没有停止线程。1234567i=499994i=499995i=499996i=499997i=499998i=499999i=500000 摘选自 java多线程核心编程技术-1.7.1]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.2.4留意i--与System.out.println()的异常]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F09%2Fsystem-out-println-exception%2F</url>
    <content type="text"><![CDATA[解决非线程安全问题使用的是synchronized关键字。但println()方法与i++使用时”有可能”出现另外一种异常情况。123456789101112131415161718192021222324252627282930313233343536/** * MyThread线程测试 * @author wuyoushan * @date 2017/3/21. */public class MyThread extends Thread &#123; private int i=5; @Override public void run() &#123; super.run(); System.out.println("i="+(i--)+"threadName="+Thread.currentThread().getName()); //注意：代码i--由前面项目中单独一行运行改成在当前项目中在println()方法中直接打印 &#125;&#125;/** * @author wuyoushan * @date 2017/3/20. */public class Run &#123; public static void main(String[] args) &#123; MyThread myThread=new MyThread(); Thread t1=new Thread(myThread); Thread t2=new Thread(myThread); Thread t3=new Thread(myThread); Thread t4=new Thread(myThread); Thread t5=new Thread(myThread); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); &#125;&#125; 程序运行后根据概率还是会出现非线程安全问题12345i=5 threadName=Thread-1i=2 threadName=Thread-5i=3 threadName=Thread-4i=4 threadName=Thread-3i=4 threadName=Thread-2 虽然println()方法在内部是同步的，但i–的操作却是进入println()之前发生的，所以有发生线程安全问题的概率。println()源码如下:123456public void println(String x) &#123; synchronized (this) &#123; print(x); newLine(); &#125;&#125; 所以，为了防止发生非线程安全问题，还是应该继续使用同步方法。 摘选自 java多线程核心编程技术-1.2.4]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.2.3非线程安全]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F09%2Fno-thread-safe%2F</url>
    <content type="text"><![CDATA[非线程安全 非线程安全主要是指多个线程对同一对象中的同一实例变量进行操作时会出现值被更变、值不同步的情况，进而影响程序的执行流程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 本类模拟成一个登录的Servlet组件 * @author wuyoushan * @date 2017/3/20. */public class LoginServlet&#123; private static String usernameRef; private static String passwordRef; public static void doPost(String username,String password)&#123; try&#123; usernameRef=username; if( username.equals("a"))&#123; Thread.sleep(5000); &#125; passwordRef=password; System.out.println("username="+usernameRef+" password="+password); &#125;catch(InterruptedException ex)&#123; ex.printStackTrace(); &#125; &#125;&#125;/** * A登录 * @author wuyoushan * @date 2017/3/20. */public class ALogin extends Thread &#123; @Override public void run() &#123; LoginServlet.doPost("a","aa"); &#125;&#125;/** * B登录 * @author wuyoushan * @date 2017/3/20. */public class BLogin extends Thread &#123; @Override public void run() &#123; LoginServlet.doPost("b","bb"); &#125;&#125; 运行结果(非线程安全的)12username=b password=bbusername=b password=aa 在LoginServlet的doPost添加synchronized关键字。12345678910111213synchronized public static void doPost(String username,String password)&#123; try&#123; usernameRef=username; if( username.equals("a"))&#123; Thread.sleep(5000); &#125; passwordRef=password; System.out.println("username="+usernameRef+" password="+password); &#125;catch(InterruptedException ex)&#123; ex.printStackTrace(); &#125; &#125; 运行结果(线程安全的)12username=a password=aausername=b password=bb 摘选自 java多线程核心编程技术-1.2.3]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.2.1线程的启动顺序与start()的执行顺序无关]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F09%2Fthread-start%2F</url>
    <content type="text"><![CDATA[执行start()方法的顺序不代表线程启动的顺序。123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * @author wuyoushan * @date 2017/3/14. */public class MyThread extends Thread &#123; private int i; public MyThread(String name)&#123; super(name); &#125; public MyThread(String name,int i)&#123; super(name); this.i=i; &#125; @Override public void run() &#123; super.run(); System.out.println("当前线程为:" +Thread.currentThread().getName()+ "\t输出的值为:"+i); &#125;&#125;/** * @author wuyoushan * @date 2017/3/14. */public class Test &#123; public static void main(String[] args) &#123; MyThread t1=new MyThread("MyThread1",1); MyThread t2=new MyThread("MyThread2",2); MyThread t3=new MyThread("MyThread3",3); MyThread t4=new MyThread("MyThread4",4); MyThread t5=new MyThread("MyThread5",5); MyThread t6=new MyThread("MyThread6",6); MyThread t7=new MyThread("MyThread7",7); t1.start(); t2.start(); t3.start(); t4.start(); t5.start(); t6.start(); t7.start(); &#125;&#125; 执行结果1234567当前线程为:MyThread1 输出的值为:1当前线程为:MyThread3 输出的值为:3当前线程为:MyThread5 输出的值为:5当前线程为:MyThread4 输出的值为:4当前线程为:MyThread2 输出的值为:2当前线程为:MyThread7 输出的值为:7当前线程为:MyThread6 输出的值为:6 摘选自 java多线程核心编程技术-1.2.1]]></content>
      <categories>
        <category>java</category>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>多线程</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建网站的第一篇博客]]></title>
    <url>%2Flearning%2Fmyblog%2Fpublic%2F2017%2F07%2F09%2Ffirst-blog%2F</url>
    <content type="text"><![CDATA[Hello World]]></content>
  </entry>
</search>